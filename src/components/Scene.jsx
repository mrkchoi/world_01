/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 portfolio03.glb 
*/

import React, { useEffect, useMemo, useRef, useState } from 'react';
import { useGLTF } from '@react-three/drei';
import { OrbitControls } from '../util/OrbitControlsCustom';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { useFrame, useThree } from '@react-three/fiber';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import {
  MeshBVH,
  MeshBVHHelper,
  StaticGeometryGenerator,
} from 'three-mesh-bvh';
import useKeyboard from '../hooks/useKeyboard';
import { useControls } from 'leva';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { create } from 'zustand';
import { ACTIONS, CharacterControls } from '../util/characterControls';

const MODEL_URL = '/assets/models/portfolio04.glb';
const params = {
  firstPerson: false,
  displayCollider: true,
  displayBVH: true,
  visualizeDepth: 10,
  gravity: -50,
  playerWalkSpeed: 10, // 10
  playerRunSpeed: 25, // 25
  playerJumpHeight: 20,
  physicsSteps: 5,
  cameraOffsetY: 1.5,
  // reset: reset,
  // startPosition: {
  //   // outdoors
  //   x: 57.428610314365,
  //   y: -8.462822423706054,
  //   z: 134.57097393901842,
  // },
  startPosition: {
    // indoors
    x: 65.00576756540369,
    y: -7.584270177612304,
    z: 77.45698842326485,
  },
};

export const useStore = create((set) => ({
  animationsMap: new Map(),
  addAnimation: (key, value) =>
    set((state) => ({ animationsMap: state.animationsMap.set(key, value) })),
  mixer: new THREE.AnimationMixer(),
  orbitControls: null,
  setOrbitControls: (value) => set(() => ({ orbitControls: value })),
}));

function Model(props) {
  const {
    nodes: characterNodes,
    scene: characterScene,
    materials: characterMaterials,
    animations: characterAnimations,
  } = useGLTF('/assets/models/crypto03.glb');
  // const {
  //   nodes: characterNodes,
  //   scene: characterScene,
  //   materials: characterMaterials,
  //   animations: characterAnimations,
  // } = useGLTF('/assets/models/Soldier.glb');

  const character = useRef(null);
  const mixer = useRef(null);
  const characterControls = useRef(null);
  const { animationsMap, addAnimation, orbitControls } = useStore();
  const { nodes, materials } = useGLTF(MODEL_URL);
  const { firstPerson, displayCollider, displayBVH, visualizeDepth, gravity } =
    useControls('Scene', {
      firstPerson: false,
      displayCollider: true,
      displayBVH: true,
      visualizeDepth: { value: 10, min: 1, max: 20, step: 1 },
      gravity: { value: -30, min: -100, max: 100, step: 1 },
    });

  const { scene, camera, gl } = useThree();
  const loader = useMemo(() => {
    const loader = new GLTFLoader();
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(dracoLoader);
    return loader;
  }, []);

  const [isSceneReady, setSceneReady] = useState(false);
  const environment = useRef(null);
  const world = useRef(null);
  const collider = useRef(null);
  const visualizer = useRef(null);
  const controls = useRef(null);
  const player = useRef(null);
  const keyboard = useKeyboard();
  const playerIsOnGround = useRef(false);
  const playerVelocity = useMemo(() => new THREE.Vector3(), []);
  const upVector = useMemo(() => new THREE.Vector3(0, 1, 0), []);
  const tempVector = useMemo(() => new THREE.Vector3(), []);
  const tempVector2 = useMemo(() => new THREE.Vector3(), []);
  const tempBox = useMemo(() => new THREE.Box3(), []);
  const tempMat = useMemo(() => new THREE.Matrix4(), []);
  const tempSegment = useMemo(() => new THREE.Line3(), []);

  useEffect(() => {
    // console.log(characterAnimations);
    mixer.current = new THREE.AnimationMixer(character.current);

    characterAnimations.forEach((clip) => {
      const action = mixer.current.clipAction(clip);
      if (clip.name === 'Jumping') {
        action.setLoop(THREE.LoopOnce);
        action.timeScale = 0.5;
      }
      addAnimation(clip.name, action);
    });
  }, []);

  useEffect(() => {
    if (controls.current && animationsMap && camera && mixer.current) {
      characterControls.current = new CharacterControls(
        character.current,
        player.current,
        mixer.current,
        animationsMap,
        controls.current,
        camera,
        ACTIONS.IDLE
      );
      // console.log(characterControls.current);
    }
  }, [animationsMap, camera]);

  useEffect(() => {
    // const gltfScene = res.scene;
    const gltfScene = world.current;
    // console.log('gltfScene: ', gltfScene);
    // gltfScene.scale.setScalar(0.01);

    const box = new THREE.Box3();
    box.setFromObject(gltfScene);
    box.getCenter(gltfScene.position).negate();
    gltfScene.updateMatrixWorld(true);

    // visual geometry setup
    const toMerge = {};
    gltfScene.traverse((c) => {
      if (c.isMesh) {
        const hex = c.material.color.getHex();
        // console.log('hex: ', hex);
        // const hex = 'FF0000';
        toMerge[hex] = toMerge[hex] || [];
        toMerge[hex].push(c);
      }
    });

    // console.log('toMerge: ', toMerge);

    environment.current = new THREE.Group();
    for (const hex in toMerge) {
      // console.log('hex: ', hex);
      const arr = toMerge[hex];
      const visualGeometries = [];
      arr.forEach((mesh) => {
        if (mesh.material.emissive.r !== 0) {
          environment.current.attach(mesh);
        } else {
          const geom = mesh.geometry.clone();
          geom.applyMatrix4(mesh.matrixWorld);
          visualGeometries.push(geom);
        }
      });

      // console.log('visualGeometries: ', visualGeometries);
      // console.log('-------------------');

      if (visualGeometries.length) {
        const newGeom = BufferGeometryUtils.mergeGeometries(visualGeometries);
        const newMesh = new THREE.Mesh(
          newGeom,
          new THREE.MeshStandardMaterial({
            color: parseInt(hex),
            shadowSide: 2,
          })
        );
        newMesh.castShadow = true;
        newMesh.receiveShadow = true;
        newMesh.material.shadowSide = 2;
        // console.log(newMesh);
        environment.current.add(newMesh);
      }
    }

    // console.log('environment.position -- BEFORE:', environment);

    const staticGenerator = new StaticGeometryGenerator(environment.current);
    staticGenerator.attributes = ['position'];

    const mergedGeometry = staticGenerator.generate();
    mergedGeometry.boundsTree = new MeshBVH(mergedGeometry);

    collider.current = new THREE.Mesh(mergedGeometry);
    collider.current.material.wireframe = true;
    collider.current.material.opacity = 0.5;
    collider.current.material.transparent = true;

    visualizer.current = new MeshBVHHelper(
      collider.current,
      params.visualizeDepth
    );
    // console.log('environment.current: ', environment.current);
    scene.add(visualizer.current);
    scene.add(collider.current);
    // scene.add(environment.current);
    // console.log('environment.position -- AFTER:', environment);
    setSceneReady(true);
    // setTimeout(() => {

    // }, 2000);

    return () => {
      if (environment.current) {
        scene.remove(environment.current);
      }
      if (collider.current) {
        scene.remove(collider.current);
      }
      if (visualizer.current) {
        scene.remove(visualizer.current);
      }
    };
  }, [loader, scene]);

  // useEffect(() => {
  //   loader.load(MODEL_URL, (res) => {
  //     const gltfScene = res.scene;
  //     console.log('gltfScene: ', gltfScene);
  //     // gltfScene.scale.setScalar(0.01);

  //     const box = new THREE.Box3();
  //     box.setFromObject(gltfScene);
  //     box.getCenter(gltfScene.position).negate();
  //     gltfScene.updateMatrixWorld(true);

  //     // visual geometry setup
  //     const toMerge = {};
  //     gltfScene.traverse((c) => {
  //       if (c.isMesh) {
  //         const hex = c.material.color.getHex();
  //         // console.log('hex: ', hex);
  //         // const hex = 'FF0000';
  //         toMerge[hex] = toMerge[hex] || [];
  //         toMerge[hex].push(c);
  //       }
  //     });

  //     // console.log('toMerge: ', toMerge);

  //     environment.current = new THREE.Group();
  //     for (const hex in toMerge) {
  //       // console.log('hex: ', hex);
  //       const arr = toMerge[hex];
  //       const visualGeometries = [];
  //       arr.forEach((mesh) => {
  //         if (mesh.material.emissive.r !== 0) {
  //           environment.current.attach(mesh);
  //         } else {
  //           const geom = mesh.geometry.clone();
  //           geom.applyMatrix4(mesh.matrixWorld);
  //           visualGeometries.push(geom);
  //         }
  //       });

  //       // console.log('visualGeometries: ', visualGeometries);
  //       // console.log('-------------------');

  //       if (visualGeometries.length) {
  //         const newGeom = BufferGeometryUtils.mergeGeometries(visualGeometries);
  //         const newMesh = new THREE.Mesh(
  //           newGeom,
  //           new THREE.MeshStandardMaterial({
  //             color: parseInt(hex),
  //             shadowSide: 2,
  //           })
  //         );
  //         newMesh.castShadow = true;
  //         newMesh.receiveShadow = true;
  //         newMesh.material.shadowSide = 2;
  //         // console.log(newMesh);
  //         environment.current.add(newMesh);
  //       }
  //     }

  //     // console.log('environment.position -- BEFORE:', environment);

  //     const staticGenerator = new StaticGeometryGenerator(environment.current);
  //     staticGenerator.attributes = ['position'];

  //     const mergedGeometry = staticGenerator.generate();
  //     mergedGeometry.boundsTree = new MeshBVH(mergedGeometry);

  //     collider.current = new THREE.Mesh(mergedGeometry);
  //     collider.current.material.wireframe = true;
  //     collider.current.material.opacity = 0.5;
  //     collider.current.material.transparent = true;

  //     visualizer.current = new MeshBVHHelper(
  //       collider.current,
  //       params.visualizeDepth
  //     );
  //     // console.log('environment.current: ', environment.current);
  //     scene.add(visualizer.current);
  //     scene.add(collider.current);
  //     // scene.add(environment.current);
  //     // console.log('environment.position -- AFTER:', environment);
  //     setSceneReady(true);
  //     // setTimeout(() => {

  //     // }, 2000);

  //     return () => {
  //       if (environment.current) {
  //         scene.remove(environment.current);
  //       }
  //       if (collider.current) {
  //         scene.remove(collider.current);
  //       }
  //       if (visualizer.current) {
  //         scene.remove(visualizer.current);
  //       }
  //     };
  //   });
  // }, [loader, scene]);

  useEffect(() => {
    if (!isSceneReady) return;
    if (player.current) {
      scene.remove(player.current);
    }
    const radius = 0.3;
    const playerCapsule = new THREE.Mesh(
      new RoundedBoxGeometry(radius * 2, 2.0, radius * 2, 10, 0.5),
      new THREE.MeshStandardMaterial({
        transparent: true,
        opacity: 0.1,
        color: 'white',
        wireframe: true,
      })
    );

    const axesHelper = new THREE.AxesHelper(1);
    playerCapsule.add(axesHelper);

    const group = new THREE.Group();
    group.add(playerCapsule);
    group.add(character.current);
    player.current = group;

    playerCapsule.geometry.translate(0, -radius, 0);
    character.current.position.set(0, -radius * 4.25, 0);
    // player.current.position.set(0, 10, 0);
    // player.current.position.set(15.75, -3, 30);
    player.current.position.set(
      params.startPosition.x,
      params.startPosition.y,
      params.startPosition.z
    );
    player.current.capsuleInfo = {
      radius: radius,
      segment: new THREE.Line3(
        new THREE.Vector3(),
        new THREE.Vector3(0, -1.0, 0.0)
      ),
    };
    // player.current.castShadow = true;
    // player.current.receiveShadow = true;
    // player.current.material.shadowSide = 2;
    scene.add(group);
    reset();
  }, [isSceneReady]);

  useEffect(() => {
    // if (!controls.current) return;
    if (firstPerson) {
      controls.current.maxPolarAngle = Math.PI;
      controls.current.minDistance = 1e-4;
      controls.current.maxDistance = 1e-4;
    } else {
      camera.position
        .sub(controls.current.target)
        .normalize()
        .multiplyScalar(8)
        .add(controls.current.target);

      controls.current.maxPolarAngle = Math.PI * 0.55;
      controls.current.minDistance = 2;
      controls.current.maxDistance = 10;
    }
  }, [camera.position, firstPerson, isSceneReady]);

  const reset = () => {
    playerVelocity.set(0, 0, 0);
    // player.current.position.set(0, 20, 0);
    player.current.position.set(
      params.startPosition.x,
      params.startPosition.y,
      params.startPosition.z
    );
    camera.position.sub(controls.current.target);
    controls.current.target.copy(player.current.position);
    camera.position.add(player.current.position);
    controls.current.update();
  };

  function updatePlayer(delta) {
    if (playerIsOnGround.current) {
      playerVelocity.y = delta * gravity;
    } else {
      playerVelocity.y += delta * gravity;
    }

    player.current.position.addScaledVector(playerVelocity, delta);

    // move the player
    const angle = controls.current.getAzimuthalAngle() || 0;
    // console.log(keyboard);
    const shift = keyboard['ShiftLeft'] || keyboard['ShiftRight'];

    if (keyboard['KeyW']) {
      tempVector.set(0, 0, -1).applyAxisAngle(upVector, angle);
      player.current.position.addScaledVector(
        tempVector,
        delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
      );
    }

    if (keyboard['KeyS']) {
      tempVector.set(0, 0, 1).applyAxisAngle(upVector, angle);
      player.current.position.addScaledVector(
        tempVector,
        delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
      );
    }

    if (keyboard['KeyA']) {
      tempVector.set(-1, 0, 0).applyAxisAngle(upVector, angle);
      player.current.position.addScaledVector(
        tempVector,
        delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
      );
    }

    if (keyboard['KeyD']) {
      tempVector.set(1, 0, 0).applyAxisAngle(upVector, angle);
      player.current.position.addScaledVector(
        tempVector,
        delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
      );
    }

    player.current.updateMatrixWorld();

    // adjust player position based on collisions
    const capsuleInfo = player.current.capsuleInfo;
    tempBox.makeEmpty();
    tempMat.copy(collider.current.matrixWorld).invert();
    tempSegment.copy(capsuleInfo.segment);

    // get the position of the capsule in the local space of the collider
    tempSegment.start
      .applyMatrix4(player.current.matrixWorld)
      .applyMatrix4(tempMat);
    tempSegment.end
      .applyMatrix4(player.current.matrixWorld)
      .applyMatrix4(tempMat);

    // get the axis aligned bounding box of the capsule
    tempBox.expandByPoint(tempSegment.start);
    tempBox.expandByPoint(tempSegment.end);

    tempBox.min.addScalar(-capsuleInfo.radius);
    tempBox.max.addScalar(capsuleInfo.radius);

    collider.current.geometry.boundsTree.shapecast({
      intersectsBounds: (box) => box.intersectsBox(tempBox),

      intersectsTriangle: (tri) => {
        // check if the triangle is intersecting the capsule and adjust the
        // capsule position if it is.
        const triPoint = tempVector;
        const capsulePoint = tempVector2;

        const distance = tri.closestPointToSegment(
          tempSegment,
          triPoint,
          capsulePoint
        );
        if (distance < capsuleInfo.radius) {
          const depth = capsuleInfo.radius - distance;
          const direction = capsulePoint.sub(triPoint).normalize();

          tempSegment.start.addScaledVector(direction, depth);
          tempSegment.end.addScaledVector(direction, depth);
        }
      },
    });

    // get the adjusted position of the capsule collider in world space after checking
    // triangle collisions and moving it. capsuleInfo.segment.start is assumed to be
    // the origin of the player model.
    const newPosition = tempVector;
    newPosition
      .copy(tempSegment.start)
      .applyMatrix4(collider.current.matrixWorld);

    // check how much the collider was moved
    const deltaVector = tempVector2;
    deltaVector.subVectors(newPosition, player.current.position);

    // if the player was primarily adjusted vertically we assume it's on something we should consider ground
    playerIsOnGround.current =
      deltaVector.y > Math.abs(delta * playerVelocity.y * 0.25);

    // console.log('deltaVector.y', deltaVector.y);

    const offset = Math.max(0.0, deltaVector.length() - 1e-5);
    deltaVector.normalize().multiplyScalar(offset);

    // adjust the player model
    player.current.position.add(deltaVector);
    // console.log(player.current.position.y);

    // const angleYCameraDirection = Math.atan2(
    //   camera.position.x - player.current.position.x,
    //   camera.position.z - player.current.position.z
    // );
    // character.current.rotation.y = angleYCameraDirection;

    if (!playerIsOnGround.current) {
      deltaVector.normalize();
      playerVelocity.addScaledVector(
        deltaVector,
        -deltaVector.dot(playerVelocity)
      );
    } else {
      playerVelocity.set(0, 0, 0);
    }

    // adjust the camera
    camera.position.sub(controls.current.target);
    const newTarget = player.current.position.clone();
    newTarget.y += params.cameraOffsetY;
    controls.current.target.copy(newTarget);
    camera.position.add(newTarget);

    // console.log(player.current.position);

    // if the player has fallen too far below the level reset their position to the start
    if (player.current.position.y < -25) {
      reset();
    }
  }

  useFrame((state, delta) => {
    if (collider.current) {
      collider.current.visible = displayCollider;
      visualizer.current.visible = displayBVH;
      visualizer.current.depth = visualizeDepth;
      visualizer.current.update();
    }
    if (collider.current && player.current) {
      for (let i = 0; i < params.physicsSteps; i++) {
        updatePlayer(delta / params.physicsSteps);
      }
    }

    if (keyboard['Space'] && playerIsOnGround.current) {
      playerVelocity.y = params.playerJumpHeight;
      playerIsOnGround.current = false;
    }

    if (characterControls.current) {
      characterControls.current.update(
        delta,
        keyboard,
        playerIsOnGround.current
      );
    }

    // if (controls.current) {
    //   console.log(controls.current);
    // }

    // console.log('playerIsOnGround', playerIsOnGround.current);
    // if (player.current) {
    //   console.log('player.current.position', player.current.position);
    // }
  });

  useEffect(() => {
    materials['Roof Glass'].transparent = true;
    materials['Roof Glass'].opacity = 0.3;

    materials['Material.004'].transparent = true;
    materials['Material.004'].opacity = 0.2;
  }, [materials]);

  return (
    <>
      <OrbitControls
        ref={controls}
        mouseButtons={{
          LEFT: THREE.MOUSE.ROTATE,
          RIGHT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.ROTATE,
        }}
      />
      {/* <group ref={character} {...props} dispose={null}>
        <group name="Scene">
          <group name="Character" rotation={[-Math.PI / 2, 0, 0]} scale={0.011}>
            <primitive
              object={characterNodes.mixamorigHips}
              castShadow
              receiveShadow
            />
            <skinnedMesh
              name="vanguard_Mesh"
              geometry={characterNodes.vanguard_Mesh.geometry}
              material={characterMaterials.VanguardBodyMat}
              skeleton={characterNodes.vanguard_Mesh.skeleton}
              castShadow
              receiveShadow
            />
            <skinnedMesh
              name="vanguard_visor"
              geometry={characterNodes.vanguard_visor.geometry}
              material={characterMaterials.Vanguard_VisorMat}
              skeleton={characterNodes.vanguard_visor.skeleton}
              castShadow
              receiveShadow
            />
          </group>
        </group>
      </group> */}
      <group ref={character} {...props} dispose={null}>
        <group name="Scene">
          <group
            name="Armature"
            rotation={[Math.PI / 2, 0, Math.PI]}
            scale={0.011}
          >
            <primitive object={characterNodes.mixamorig1Hips} />
            <skinnedMesh
              name="Ch45"
              geometry={characterNodes.Ch45.geometry}
              // material={characterMaterials.Ch45_Body}
              skeleton={characterNodes.Ch45.skeleton}
            >
              <meshStandardMaterial
                color="darkgrey"
                // skinning={true}
                metalness={1}
                roughness={0}
                // transparent={true}
                // opacity={0.8}
                side={THREE.DoubleSide}
              />
            </skinnedMesh>
          </group>
        </group>
      </group>
      <group ref={world} {...props} dispose={null}>
        <mesh
          geometry={nodes.Cube013.geometry}
          material={materials.circlePlatform}
          position={[-62.164, -0.004, -133.957]}
          rotation={[0, 0.097, 0]}
        />
        <mesh
          geometry={nodes.Cube014.geometry}
          material={materials.circlePlatform}
          position={[-69.367, 0.003, -135.99]}
          rotation={[0, 0.862, 0]}
        />
        <mesh
          geometry={nodes.archWall01.geometry}
          material={materials.walls}
          position={[-104.611, 5.354, -159.279]}
          rotation={[0, -0.817, 0]}
        />
        <mesh
          geometry={nodes.archWall01001.geometry}
          material={materials.walls}
          position={[-92.549, 5.354, -172.955]}
          rotation={[0, -0.578, 0]}
        />
        <mesh
          geometry={nodes.Plane.geometry}
          material={materials.ocean}
          position={[-94.265, 1.248, -159.12]}
          rotation={[0, -0.701, 0]}
        />
        <mesh
          geometry={nodes.Icosphere001.geometry}
          material={materials.sculpture}
          position={[-149.762, 13.073, -210.081]}
          rotation={[-1.156, 0, 0]}
        />
        <mesh
          geometry={nodes.Cube015.geometry}
          material={materials.walls}
          position={[-60.858, 1.25, -132.936]}
          rotation={[0, -0.663, 0]}
        />
        <mesh
          geometry={nodes.Plane001.geometry}
          material={materials.roofEntrance}
          position={[0.565, 4.3, -8.255]}
          scale={[1, 0.836, 1]}
        />
        <mesh
          geometry={nodes.entranceRoofGlass.geometry}
          material={materials['Roof Glass']}
          position={[0.837, 4.165, -8.272]}
        />
        <mesh
          geometry={nodes.Plane002.geometry}
          material={materials.floorEntrance}
          position={[1.368, -1.078, 100.563]}
        />
        <mesh
          geometry={nodes.Landscape001.geometry}
          material={materials.rock}
          position={[9.565, 0.784, -5.172]}
          rotation={[-0.589, 0.785, 1.361]}
        />
        <mesh
          geometry={nodes.Circle.geometry}
          material={materials.floorInterior}
          position={[-1.738, 0.001, -30.89]}
        />
        <mesh
          geometry={nodes.Plane003.geometry}
          material={materials.floorInterior}
          position={[6.446, 0.001, -60.331]}
        />
        <mesh
          geometry={nodes.BezierCurve.geometry}
          material={materials.floorInterior}
          position={[-5.586, 0.001, -86.258]}
        />
        <mesh
          geometry={nodes.Plane004.geometry}
          material={nodes.Plane004.material}
          position={[2.279, -0.019, -70.591]}
        />
        <mesh
          geometry={nodes.Landscape002.geometry}
          material={materials.rock}
          position={[-8.348, 0.615, -3.996]}
          rotation={[-2.187, -0.154, -1.726]}
        />
        <mesh
          geometry={nodes.Landscape003.geometry}
          material={materials.rock}
          position={[13.706, -0.38, -1.042]}
          rotation={[-2.62, -0.017, -2.525]}
        />
        <mesh
          geometry={nodes.Landscape004.geometry}
          material={materials.rock}
          position={[-12.522, -0.38, -1.903]}
          rotation={[0.248, 0.216, 1.711]}
        />
        <mesh
          geometry={nodes.entrance01.geometry}
          material={materials.walls}
          position={[0, -0.028, -13.737]}
        />
        <mesh
          geometry={nodes.entranceCurvedWall.geometry}
          material={materials.walls}
          position={[-2.9, 4.431, -18.037]}
        />
        <mesh
          geometry={nodes.floor.geometry}
          material={materials.floorInterior}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.pedestal02.geometry}
          material={materials.circlePlatform}
          position={[-5.211, 0.496, -30.827]}
        />
        <mesh
          geometry={nodes.entranceSphere.geometry}
          material={materials.sculpture}
          position={[-5.211, 1.668, -30.827]}
        />
        <mesh
          geometry={nodes.entranceRoofCutout.geometry}
          material={materials.walls}
          position={[-5.209, 7.766, -30.899]}
        />
        <mesh
          geometry={nodes.straightRoom.geometry}
          material={materials.walls}
          position={[6.191, -0.001, -41.53]}
        />
        <mesh
          geometry={nodes.Cube004.geometry}
          material={nodes.Cube004.material}
          position={[10.892, 3, -52.699]}
          rotation={[0, -0.42, 0]}
          scale={[1.271, 1, 1.059]}
        />
        <mesh
          geometry={nodes.circularRoom.geometry}
          material={materials.walls}
          position={[-38.268, 0.726, -114.098]}
          rotation={[0, -0.113, 0]}
        />
        <mesh
          geometry={nodes.Cylinder001.geometry}
          material={materials.walls}
          position={[-39.042, 0.991, -118.189]}
        />
        <mesh
          geometry={nodes.Cylinder.geometry}
          material={materials.circlePlatform}
          position={[-38.268, 0.16, -114.098]}
        />
        <mesh
          geometry={nodes.TorusKnot.geometry}
          material={materials.sculpture}
          position={[-38.268, 4.353, -114.098]}
          rotation={[0.118, 0.573, -0.109]}
        />
        <mesh
          geometry={nodes.water.geometry}
          material={materials['Material.004']}
          position={[-38.268, 0.126, -114.098]}
        />
        <mesh
          geometry={nodes.Cube009.geometry}
          material={materials.benches}
          position={[-4.492, 0.235, -49.039]}
          rotation={[0, 0, Math.PI]}
        />
        <mesh
          geometry={nodes.Cube010.geometry}
          material={materials.benches}
          position={[-11.588, 0.235, -89.045]}
          rotation={[-Math.PI, -1.389, 0]}
        />
        <mesh
          geometry={nodes.Cylinder004.geometry}
          material={materials.walls}
          position={[10.297, 13.829, -80.145]}
        />
        <mesh
          geometry={nodes.Cylinder005.geometry}
          material={materials.walls}
          position={[1.025, 13.875, -97.349]}
        />
        <mesh
          geometry={nodes.Icosphere.geometry}
          material={materials.sculpture}
          position={[16.275, 0.664, -73.274]}
        />
        <mesh
          geometry={nodes.Cube011.geometry}
          material={materials['pillar.001']}
          position={[16.643, 0, -31.631]}
        />
        <mesh
          geometry={nodes.Cube012.geometry}
          material={materials['pillar.001']}
          position={[16.643, 0, -35.363]}
        />
        <mesh
          geometry={nodes.Cube016.geometry}
          material={materials.Canvas001}
          position={[10.892, 3, -52.699]}
          rotation={[0, -0.42, 0]}
          scale={[1.27, 1, 1.059]}
        />
        <mesh
          geometry={nodes.entranceRoof.geometry}
          material={materials.walls}
          position={[0, -0.039, -13.737]}
        />
        <mesh
          geometry={nodes.floor001.geometry}
          material={materials.floorEntrance}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.entrance02001.geometry}
          material={materials.walls}
          position={[-1.231, 5.329, -29.409]}
        />
        <mesh
          geometry={nodes.Cube018.geometry}
          material={nodes.Cube018.material}
          position={[2.256, 3, -70.992]}
          rotation={[0, 0.351, 0]}
          scale={[1.271, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube025.geometry}
          material={materials.Canvas001}
          position={[2.256, 3, -70.992]}
          rotation={[0, 0.351, 0]}
          scale={[1.27, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube001.geometry}
          material={nodes.Cube001.material}
          position={[10.536, 3, -89.655]}
          rotation={[0, -0.329, 0]}
          scale={[1.271, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube017.geometry}
          material={materials.Canvas001}
          position={[10.536, 3, -89.655]}
          rotation={[0, -0.329, 0]}
          scale={[1.27, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube023.geometry}
          material={materials.benches}
          position={[12.409, 0.235, -31.067]}
          rotation={[Math.PI, Math.PI / 2, 0]}
        />
        <mesh
          geometry={nodes.Cube024.geometry}
          material={materials.benches}
          position={[17.132, 0.235, -39.579]}
          rotation={[-Math.PI, 0, 0]}
        />
        <mesh
          geometry={nodes.Cube005.geometry}
          material={nodes.Cube005.material}
          position={[-7.389, 3, -106.224]}
          rotation={[0, 0.59, 0]}
          scale={[1.271, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube006.geometry}
          material={materials.Canvas001}
          position={[-7.389, 3, -106.224]}
          rotation={[0, 0.59, 0]}
          scale={[1.27, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube007.geometry}
          material={nodes.Cube007.material}
          position={[-30.857, 3, -90.14]}
          rotation={[-Math.PI, 0.955, -Math.PI]}
          scale={[1.271, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube019.geometry}
          material={materials.Canvas001}
          position={[-30.857, 3, -90.14]}
          rotation={[-Math.PI, 0.955, -Math.PI]}
          scale={[1.27, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube002.geometry}
          material={nodes.Cube002.material}
          position={[-58.277, 3, -98.212]}
          rotation={[0, 1.471, 0]}
          scale={[1.271, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube003.geometry}
          material={materials.Canvas001}
          position={[-58.277, 3, -98.212]}
          rotation={[0, 1.471, 0]}
          scale={[1.27, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube008.geometry}
          material={nodes.Cube008.material}
          position={[-63.811, 3, -118.698]}
          rotation={[0, 0.638, 0]}
          scale={[1.271, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Cube020.geometry}
          material={materials.Canvas001}
          position={[-63.811, 3, -118.698]}
          rotation={[0, 0.638, 0]}
          scale={[1.27, 1, 1.059]}
        />
        <mesh
          geometry={nodes.Sorento_Sculpture.geometry}
          material={materials.sculpture}
          position={[-53.53, 0.004, -137.858]}
        />
        <mesh
          geometry={nodes.Human_walking_18m.geometry}
          material={materials.benches}
          position={[7.853, -0.045, -44.794]}
          rotation={[Math.PI, 0, Math.PI]}
          scale={1.095}
        />
        <mesh
          geometry={nodes.Human_walking_18m001.geometry}
          material={materials.benches}
          position={[-21.263, -0.045, -90.278]}
          rotation={[0, -1.34, 0]}
          scale={1.095}
        />
      </group>
    </>
  );
}

useGLTF.preload(MODEL_URL);

export default Model;
