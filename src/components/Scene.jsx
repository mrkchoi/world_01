/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 portfolio03.glb 
*/

import React, { useEffect, useMemo, useRef, useState } from 'react';
import { MeshReflectorMaterial, useGLTF } from '@react-three/drei';
import { OrbitControls } from '../util/OrbitControlsCustom';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { render, useFrame, useThree } from '@react-three/fiber';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import {
  MeshBVH,
  MeshBVHHelper,
  StaticGeometryGenerator,
} from 'three-mesh-bvh';
import useKeyboard from '../hooks/useKeyboard';
import { useControls } from 'leva';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { create } from 'zustand';
import { ACTIONS, CharacterControls } from '../util/characterControls';
import { v4 as uuidv4 } from 'uuid';
import { Fluid } from '@alienkitty/alien.js/three';
import videoSource from '/assets/video/zajno_showreel.mp4';
import floorTexture from '/assets/textures/cineshader_floor.jpeg';
import tileTexture from '/assets/textures/Tiles076_4K-JPG_Color.jpg';
import bakedFloor from '/assets/textures/baked/bakedFloor01.webp';
import floorTextureBaked01 from '/assets/textures/baked/floor001_Bake1_CyclesBake_COMBINED.png';

var textureURL =
  'https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/lroc_color_poles_1k.jpg';
var displacementURL =
  'https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/ldem_3_8bit.jpg';
var worldURL = 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/hipp8_s.jpg';

const MODEL_URL = '/assets/models/portfolio06.glb';
const params = {
  firstPerson: true,
  displayCollider: false,
  displayBVH: false,
  visualizeDepth: 10,
  gravity: -50,
  playerWalkSpeed: 10, // 10
  playerRunSpeed: 50, // 25
  playerJumpHeight: 20,
  physicsSteps: 5,
  cameraOffsetY: 1.5,
  // startPosition: {
  //   // debug
  //   x: -2.59715775502132,
  //   y: -7.57213251605731,
  //   z: 7.25489462321836,
  // },
  startPosition: {
    // outdoors front
    x: 2,
    y: 10,
    z: 30.84643452606501,
  },
  // startPosition: {
  //   // outdoors back
  //   x: -75.87103553276128,
  //   y: 2,
  //   z: -41.36782889639384,
  // },
  // startPosition: {
  //   // indoors entrance
  //   x: 24.96,
  //   y: 20,
  //   z: 75.35,
  // },
  // startPosition: {
  //   // indoors entrance
  //   x: -38,
  //   y: 10,
  //   z: -110,
  // },
};

export const useStore = create((set) => ({
  animationsMap: new Map(),
  addAnimation: (key, value) =>
    set((state) => ({ animationsMap: state.animationsMap.set(key, value) })),
  mixer: new THREE.AnimationMixer(),
  orbitControls: null,
  setOrbitControls: (value) => set(() => ({ orbitControls: value })),
}));

function Model(props) {
  const [video] = useState(() => {
    const video = document.createElement('video');
    video.src = videoSource;
    video.loop = true;
    video.muted = true;
    video.autoplay = true;
    video.crossOrigin = 'anonymous';
    video.play();
    return video;
  });

  const { nodes: characterNodes, animations: characterAnimations } = useGLTF(
    '/assets/models/crypto03.glb'
  );

  const { scene, camera, gl } = useThree();
  const character = useRef(null);
  const mixer = useRef(null);
  const characterControls = useRef(null);
  const { animationsMap, addAnimation } = useStore();
  const { nodes, materials } = useGLTF(MODEL_URL);
  const { displayCollider, displayBVH, visualizeDepth, gravity } = useControls(
    'Scene',
    {
      displayCollider: false,
      displayBVH: false,
      visualizeDepth: { value: 10, min: 1, max: 20, step: 1 },
      gravity: { value: -30, min: -100, max: 100, step: 1 },
    },
    { collapsed: true }
  );

  const skySphere = useRef(null);

  // const { iterate, density, velocity, pressure, curl, radius } = useControls(
  //   'Fluid',
  //   {
  //     iterate: { value: 3, min: 1, max: 10 },
  //     density: { value: 0.95, min: 0, max: 1 },
  //     velocity: { value: 0.98, min: 0, max: 1 },
  //     pressure: { value: 0.8, min: 0, max: 1 },
  //     curl: { value: 2.5, min: 0, max: 50 },
  //     radius: { value: 0.3, min: 0.01, max: 0.5 },
  //   },
  //   { collapsed: true }
  // );
  // const canvas01 = useRef(null);
  // const canvas02 = useRef(null);
  // const canvas03 = useRef(null);
  // const canvas04 = useRef(null);
  // const canvas05 = useRef(null);
  // const canvas06 = useRef(null);
  // const canvas07 = useRef(null);
  // const mouse = useRef({
  //   world: new THREE.Vector2(),
  //   uv: new THREE.Vector2(),
  //   isInit: false,
  // });
  // const raycaster = new THREE.Raycaster();
  // const fluid = useRef(
  //   new Fluid(gl, {
  //     curlStrength: 0,
  //   })
  // );

  // useEffect(() => {
  //   const fluidInstance = fluid.current;

  //   return () => {
  //     fluidInstance.destroy();
  //   };
  // }, []);

  // useEffect(() => {
  //   const handleMouseMove = (e) => {
  //     // if pointer is down, don't do anything
  //     // if (e.buttons) return;
  //     const event = {
  //       x: (e.clientX / window.innerWidth) * 2 - 1,
  //       y: -(e.clientY / window.innerHeight) * 2 + 1,
  //     };

  //     if (!mouse.current.isInit) {
  //       mouse.current.isInit = true;
  //       mouse.current.world.copy(event);
  //       mouse.current.uv.copy(event);
  //     }

  //     // console.log(mouse.current.world, mouse.current.uv);
  //     raycaster.setFromCamera(mouse.current.world, camera);
  //     const intersects = raycaster.intersectObjects([
  //       canvas01.current,
  //       canvas02.current,
  //       canvas03.current,
  //       canvas04.current,
  //       canvas05.current,
  //       canvas06.current,
  //       canvas07.current,
  //     ]);

  //     // console.log('intersects: ', intersects);
  //     if (intersects.length > 0) {
  //       const { x, y } = intersects[0].uv;

  //       const deltaX = x - mouse.current.uv.x;
  //       const deltaY = y - mouse.current.uv.y;

  //       mouse.current.uv.copy(intersects[0].uv);

  //       if (Math.abs(deltaX) || Math.abs(deltaY)) {
  //         // console.log(x, y, deltaX, deltaY);
  //         if (fluid.current) {
  //           fluid.current.splats.push({
  //             x: x,
  //             y: y,
  //             dx: deltaX * 5000,
  //             dy: deltaY * 5000,
  //           });
  //         }
  //       }
  //     }

  //     mouse.current.world.copy(event);
  //   };

  //   window.addEventListener('mousemove', handleMouseMove);

  //   return () => {
  //     window.removeEventListener('mousemove', handleMouseMove);
  //   };
  // }, []);

  const isFirstPerson = useRef(true);
  const [{ firstPerson }, setFirstPerson] = useControls('Scene', () => ({
    firstPerson: true,
  }));

  const loader = useMemo(() => {
    const loader = new GLTFLoader();
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(dracoLoader);
    return loader;
  }, []);

  const [isSceneReady, setSceneReady] = useState(false);
  const world = useRef(null);
  const collider = useRef(null);
  const visualizer = useRef(null);
  const controls = useRef(null);
  const player = useRef(null);
  const keyboard = useKeyboard();
  const playerIsOnGround = useRef(false);
  const playerVelocity = useMemo(() => new THREE.Vector3(), []);
  const upVector = useMemo(() => new THREE.Vector3(0, 1, 0), []);
  const tempVector = useMemo(() => new THREE.Vector3(), []);
  const tempVector2 = useMemo(() => new THREE.Vector3(), []);
  const tempBox = useMemo(() => new THREE.Box3(), []);
  const tempMat = useMemo(() => new THREE.Matrix4(), []);
  const tempSegment = useMemo(() => new THREE.Line3(), []);

  useEffect(() => {
    mixer.current = new THREE.AnimationMixer(character.current);

    characterAnimations.forEach((clip) => {
      const action = mixer.current.clipAction(clip);
      if (clip.name === 'Jumping') {
        action.setLoop(THREE.LoopOnce);
        action.timeScale = 0.5;
      } else {
        action.timeScale = 1.25;
      }
      addAnimation(clip.name, action);
    });
  }, []);

  useEffect(() => {
    if (controls.current && animationsMap && camera && mixer.current) {
      characterControls.current = new CharacterControls(
        character.current,
        player.current,
        mixer.current,
        animationsMap,
        controls.current,
        camera,
        ACTIONS.IDLE
      );
    }
  }, [animationsMap, camera]);

  useEffect(() => {
    const gltfScene = world.current;

    const box = new THREE.Box3();
    box.setFromObject(gltfScene);
    box.getCenter(gltfScene.position).negate();
    // console.log(box);
    gltfScene.updateMatrixWorld(true);

    const staticGenerator = new StaticGeometryGenerator(gltfScene);
    staticGenerator.attributes = ['position'];

    const mergedGeometry = staticGenerator.generate();
    mergedGeometry.boundsTree = new MeshBVH(mergedGeometry);

    collider.current = new THREE.Mesh(mergedGeometry);
    collider.current.material.wireframe = true;
    collider.current.material.opacity = 0.5;
    collider.current.material.transparent = true;

    visualizer.current = new MeshBVHHelper(
      collider.current,
      params.visualizeDepth
    );

    scene.add(visualizer.current);
    scene.add(collider.current);
    setSceneReady(true);

    return () => {
      if (collider.current) {
        scene.remove(collider.current);
      }
      if (visualizer.current) {
        scene.remove(visualizer.current);
      }
    };
  }, [loader, scene]);

  useEffect(() => {
    if (!isSceneReady) return;
    if (player.current) {
      scene.remove(player.current);
    }
    const radius = 0.5;
    const playerCapsule = new THREE.Mesh(
      new RoundedBoxGeometry(radius * 2, 2.0, radius * 2, 10, 0.5),
      new THREE.MeshBasicMaterial({
        transparent: true,
        opacity: 0,
        // color: 'white',
        wireframe: false,
        depthTest: false,
        depthWrite: false,
      })
    );

    // const axesHelper = new THREE.AxesHelper(1);
    // playerCapsule.add(axesHelper);

    const group = new THREE.Group();
    group.add(playerCapsule);
    group.add(character.current);
    player.current = group;

    playerCapsule.geometry.translate(0, -radius, 0);
    character.current.position.set(0, -radius * 3, 0);
    // player.current.position.set(0, 10, 0);
    // player.current.position.set(15.75, -3, 30);
    player.current.position.set(
      params.startPosition.x,
      params.startPosition.y,
      params.startPosition.z
    );
    player.current.capsuleInfo = {
      radius: radius,
      segment: new THREE.Line3(
        new THREE.Vector3(),
        new THREE.Vector3(0, -1.0, 0.0)
      ),
    };
    // player.current.castShadow = true;
    // player.current.receiveShadow = true;
    // player.current.material.shadowSide = 2;
    scene.add(group);
    reset();
  }, [isSceneReady]);

  useEffect(() => {
    // if (!controls.current) return;
    if (firstPerson) {
      controls.current.maxPolarAngle = Math.PI;
      controls.current.minDistance = 1e-4;
      controls.current.maxDistance = 1e-4;
    } else {
      camera.position
        .sub(controls.current.target)
        .normalize()
        .multiplyScalar(8)
        .add(controls.current.target);

      controls.current.maxPolarAngle = Math.PI * 0.55;
      controls.current.minDistance = 2;
      controls.current.maxDistance = 10;
    }
  }, [camera.position, firstPerson, isSceneReady]);

  const reset = () => {
    playerVelocity.set(0, 0, 0);
    // player.current.position.set(0, 20, 0);
    player.current.position.set(
      params.startPosition.x,
      params.startPosition.y,
      params.startPosition.z
    );
    camera.position.sub(controls.current.target);
    controls.current.target.copy(player.current.position);
    camera.position.add(player.current.position);
    controls.current.update();
  };

  function updatePlayer(delta) {
    if (playerIsOnGround.current) {
      playerVelocity.y = delta * gravity;
    } else {
      playerVelocity.y += delta * gravity;
    }

    player.current.position.addScaledVector(playerVelocity, delta);

    // console.log(player.current.position);
    // move the player
    const angle = controls.current.getAzimuthalAngle() || 0;
    const shift = keyboard['ShiftLeft'] || keyboard['ShiftRight'];

    if (keyboard['KeyW']) {
      tempVector.set(0, 0, -1).applyAxisAngle(upVector, angle);
      player.current.position.addScaledVector(
        tempVector,
        delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
      );
    }

    if (keyboard['KeyS']) {
      tempVector.set(0, 0, 1).applyAxisAngle(upVector, angle);
      player.current.position.addScaledVector(
        tempVector,
        delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
      );
    }

    if (keyboard['KeyA']) {
      tempVector.set(-1, 0, 0).applyAxisAngle(upVector, angle);
      player.current.position.addScaledVector(
        tempVector,
        delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
      );
    }

    if (keyboard['KeyD']) {
      tempVector.set(1, 0, 0).applyAxisAngle(upVector, angle);
      player.current.position.addScaledVector(
        tempVector,
        delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
      );
    }

    player.current.updateMatrixWorld();

    // adjust player position based on collisions
    const capsuleInfo = player.current.capsuleInfo;
    tempBox.makeEmpty();
    tempMat.copy(collider.current.matrixWorld).invert();
    tempSegment.copy(capsuleInfo.segment);

    // get the position of the capsule in the local space of the collider
    tempSegment.start
      .applyMatrix4(player.current.matrixWorld)
      .applyMatrix4(tempMat);
    tempSegment.end
      .applyMatrix4(player.current.matrixWorld)
      .applyMatrix4(tempMat);

    // get the axis aligned bounding box of the capsule
    tempBox.expandByPoint(tempSegment.start);
    tempBox.expandByPoint(tempSegment.end);

    tempBox.min.addScalar(-capsuleInfo.radius);
    tempBox.max.addScalar(capsuleInfo.radius);

    collider.current.geometry.boundsTree.shapecast({
      intersectsBounds: (box) => box.intersectsBox(tempBox),

      intersectsTriangle: (tri) => {
        // check if the triangle is intersecting the capsule and adjust the
        // capsule position if it is.
        const triPoint = tempVector;
        const capsulePoint = tempVector2;

        const distance = tri.closestPointToSegment(
          tempSegment,
          triPoint,
          capsulePoint
        );
        if (distance < capsuleInfo.radius) {
          const depth = capsuleInfo.radius - distance;
          const direction = capsulePoint.sub(triPoint).normalize();

          tempSegment.start.addScaledVector(direction, depth);
          tempSegment.end.addScaledVector(direction, depth);
        }
      },
    });

    // get the adjusted position of the capsule collider in world space after checking
    // triangle collisions and moving it. capsuleInfo.segment.start is assumed to be
    // the origin of the player model.
    const newPosition = tempVector;
    newPosition
      .copy(tempSegment.start)
      .applyMatrix4(collider.current.matrixWorld);

    // check how much the collider was moved
    const deltaVector = tempVector2;
    deltaVector.subVectors(newPosition, player.current.position);

    // if the player was primarily adjusted vertically we assume it's on something we should consider ground
    playerIsOnGround.current =
      deltaVector.y > Math.abs(delta * playerVelocity.y * 0.25);

    const offset = Math.max(0.0, deltaVector.length() - 1e-5);
    deltaVector.normalize().multiplyScalar(offset);

    // adjust the player model
    player.current.position.add(deltaVector);

    if (!playerIsOnGround.current) {
      deltaVector.normalize();
      playerVelocity.addScaledVector(
        deltaVector,
        -deltaVector.dot(playerVelocity)
      );
    } else {
      playerVelocity.set(0, 0, 0);
    }

    // adjust the camera
    camera.position.sub(controls.current.target);
    const newTarget = player.current.position.clone();
    newTarget.y += params.cameraOffsetY;
    controls.current.target.copy(newTarget);
    camera.position.add(newTarget);

    // if the player has fallen too far below the level reset their position to the start
    if (player.current.position.y < -25) {
      reset();
    }
  }

  useEffect(() => {
    const handleKeyDown = (event) => {
      if (keyboard['ShiftLeft'] && keyboard['KeyF']) {
        setFirstPerson({ firstPerson: isFirstPerson.current ? false : true });
        isFirstPerson.current = !isFirstPerson.current;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  useEffect(() => {
    console.log(nodes.circularRoomPoolWater);
  }, []);

  const videoTexture = useMemo(() => {
    const texture = new THREE.VideoTexture(video);
    // texture.minFilter = THREE.LinearFilter;
    // texture.magFilter = THREE.LinearFilter;
    // texture.format = THREE.RGBFormat;
    texture.flipY = false;
    return texture;
  }, [video]);

  const floorBakedTexture = useMemo(() => {
    const texture = new THREE.TextureLoader().load(bakedFloor);
    // texture.flipY = false;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;

    return texture;
  }, []);

  const floorTextureMap = useMemo(() => {
    const texture = new THREE.TextureLoader().load(floorTexture);
    texture.flipY = false;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(25, 25);
    return texture;
  }, []);

  const moonTexture = useMemo(() => {
    const texture = new THREE.TextureLoader().load(textureURL);
    texture.flipY = false;
    return texture;
  }, []);

  const moonDisplacementTexture = useMemo(() => {
    const texture = new THREE.TextureLoader().load(displacementURL);
    texture.flipY = false;
    return texture;
  }, []);

  const uniforms = useMemo(
    () => ({
      uTime: { value: 0 },
      uVideoTexture: { value: videoTexture },
      uFluid: { value: null },
      // uRGBShift: { value: 1 },
    }),
    []
  );

  const shaderMaterial = useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: `
        varying vec2 vUv;

        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform sampler2D uVideoTexture;
        uniform sampler2D uFluid;
        // uniform int uRGBShift;

        varying vec2 vUv;

        void main() {
          vec3 fluid = texture2D(uFluid, vUv).rgb;
          vec2 uv = vUv;
          vec2 uv2 = vUv - (fluid.xy * .001);
          vec4 color = texture2D(uVideoTexture, uv2);
          // vec3 rgb = fluid * 0.0001;

          // color.r = texture2D(uVideoTexture, vec2(uv.x+rgb.x, uv.y+rgb.y)).r;
          // color.g = texture2D(uVideoTexture, vec2(uv.x-rgb.x, uv.y+rgb.y)).g;
          // color.b = texture2D(uVideoTexture, vec2(uv.x-rgb.x, uv.y-rgb.y)).b;
          gl_FragColor = color;
          // gl_FragColor = vec4(vUv, 1.0, 1.0);
        }
      `,
    });
  }, []);

  // const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512);
  // cubeRenderTarget.texture.type = THREE.HalfFloatType;

  // useEffect(() => {
  //   if (cubeRenderTarget.current) {
  //     cubeRenderTarget.current.texture.type = THREE.HalfFloatType;
  //   }
  // }, []);
  // const cubeCamera = new THREE.CubeCamera(0.1, 5000, cubeRenderTarget);
  // scene.add(cubeCamera);

  // const accentLightMaterial = useMemo(() => {
  //   return new THREE.MeshBasicMaterial({
  //     color: '#aaaaaa',
  //   });
  // }, []);

  useFrame((state, delta) => {
    if (collider.current) {
      collider.current.visible = displayCollider;
      visualizer.current.visible = displayBVH;
      visualizer.current.depth = visualizeDepth;
      visualizer.current.update();
    }
    if (collider.current && player.current) {
      for (let i = 0; i < params.physicsSteps; i++) {
        updatePlayer(delta / params.physicsSteps);
      }
    }

    if (keyboard['Space'] && playerIsOnGround.current) {
      playerVelocity.y = params.playerJumpHeight;
      playerIsOnGround.current = false;
    }

    if (characterControls.current) {
      characterControls.current.update(
        delta,
        keyboard,
        playerIsOnGround.current
      );
    }

    // update uTime uniform
    uniforms.uTime.value = state.clock.elapsedTime;

    // if (fluid.current) {
    //   if (fluid.current.uniform) {
    //     canvas01.current.material.uniforms.uFluid.value =
    //       fluid.current.uniform.value;
    //   }

    //   fluid.current.iterate = iterate;
    //   fluid.current.densityDissipation = density;
    //   fluid.current.velocityDissipation = velocity;
    //   fluid.current.pressureDissipation = pressure;
    //   fluid.current.curlStrength = curl;
    //   fluid.current.radius = radius;
    //   fluid.current.update();
    // }

    // if (cubeCamera) {
    //   cubeCamera.update(gl, scene);
    // }
  });

  useEffect(() => {
    // console.log('materials.floor001_Baked: ', materials.floor001_Baked);
    // gl.toneMapping = THREE.ACESFilmicToneMapping;
    // materials.floor001_Baked.toneMapped = false;
    // gl.outputEncoding = THREE.sRGBEncoding;
  }, []);

  const floorTexture01 = useMemo(() => {
    const texture = new THREE.TextureLoader().load(floorTextureBaked01);
    texture.flipY = false;
    return texture;
  }, []);

  return (
    <>
      <OrbitControls
        ref={controls}
        mouseButtons={{
          LEFT: THREE.MOUSE.ROTATE,
          RIGHT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.ROTATE,
        }}
      />
      <group ref={character} {...props} dispose={null}>
        <group name="Scene">
          <group
            name="Armature"
            rotation={[Math.PI / 2, 0, Math.PI]}
            scale={0.011}
          >
            <primitive object={characterNodes.mixamorig1Hips} />
            <skinnedMesh
              name="Ch45"
              geometry={characterNodes.Ch45.geometry}
              // material={characterMaterials.Ch45_Body}
              skeleton={characterNodes.Ch45.skeleton}
              castShadow
              receiveShadow
            >
              {/* <meshLambertMaterial /> */}
              <meshStandardMaterial
                color="white"
                // map={videoTexture}
                roughness={0}
                metalness={1}
                emissive={'#ddd'}
                emissiveIntensity={0.3}
                wireframe={true}
                wireframeLinewidth={0.1}
              />
              {/* <meshToonMaterial color="white" /> */}
              {/* <meshMatcapMaterial /> */}
              {/* <meshStandardMaterial
                color="white"
                map={videoTexture}
                roughness={1}
              /> */}
            </skinnedMesh>
          </group>
        </group>
      </group>
      <group ref={world} {...props} dispose={null}>
        <group
          position={[-81.585, 1.546, -155.711]}
          rotation={[-Math.PI / 2, 0, 0]}
        >
          <group rotation={[Math.PI / 2, 0, 0]}>
            <group position={[-0.301, -0.125, -0.095]}>
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0.geometry}
                material={materials.pine_2_1Mat}
              />
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0_1.geometry}
                material={materials.trunk_2_1_0Mat}
              />
            </group>
            <group
              position={[-5.016, -0.125, 5.02]}
              rotation={[-Math.PI, 0.425, -Math.PI]}
            >
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0003.geometry}
                material={materials.pine_2_1Mat}
              />
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0003_1.geometry}
                material={materials.trunk_2_1_0Mat}
              />
            </group>
          </group>
        </group>
        <mesh
          geometry={nodes.rockGroup_Baked.geometry}
          material={materials.rockGroup_Baked}
          position={[-38.04, 0.134, -113.847]}
          rotation={[1.81, 0.887, 2.375]}
        />
        <mesh
          geometry={nodes.entranceWalls_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[0, -0.028, -13.737]}
        />
        <mesh
          geometry={nodes.entranceCurvedWall_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[-6.25, 4.315, -18.294]}
        />
        <mesh
          geometry={nodes.entranceRoof_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[-0.001, 3.242, -13.737]}
        />
        <mesh
          geometry={nodes.entranceRoofWindows_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[2.223, 7.458, -8.255]}
        />
        <mesh
          geometry={nodes.entranceCurvedRoomPedestal_Baked.geometry}
          material={materials.entranceFloorAndPedestal_Baked}
          position={[-5.211, 0.496, -30.827]}
        />
        <mesh
          geometry={nodes.floor001_Baked.geometry}
          material={materials.entranceFloorAndPedestal_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.entranceCurvedRoom_Baked.geometry}
          material={materials.entranceRoundWalls_Baked}
          position={[-4.383, 5.782, -31.047]}
        />
        <mesh
          geometry={nodes.entranceCurvedRoomTop_Baked.geometry}
          material={materials.entranceRoundWalls_Baked}
          position={[-1.632, 9.146, -30.827]}
        />
        <mesh
          geometry={nodes.mainRoomTop001_Baked.geometry}
          material={materials.mainHallFloorAndTop_Baked}
          position={[6.161, 16.353, -65.066]}
        />
        <mesh
          geometry={nodes.mainRoomWalls_Baked.geometry}
          material={materials.mainHallWalls_Baked}
          position={[6.191, -0.001, -41.53]}
        />
        <mesh
          geometry={nodes.mainRoomTop002_Baked.geometry}
          material={materials.mainHallWalls_Baked}
          position={[0.682, 16.351, -97.22]}
        />
        <mesh
          geometry={nodes.floor003_Baked.geometry}
          material={materials.floor003_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.floor003001_Baked.geometry}
          material={materials.mainCircularRoomFloors_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.floor003002_Baked.geometry}
          material={materials.mainCircularRoomFloors_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.circularRoom_Baked.geometry}
          material={materials.circularRoom_Baked}
          position={[-38.268, 0.726, -114.098]}
          rotation={[0, -0.113, 0]}
        />
        <mesh
          geometry={nodes.circularRoomTop_Baked.geometry}
          material={materials.circularRoomTop_Baked}
          position={[-38.268, 18.336, -114.098]}
        />
        <mesh
          geometry={nodes.floor002_Baked.geometry}
          material={materials.floor002_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.logoSculpture_Baked.geometry}
          material={materials.logoSculpture_Baked}
          position={[-5.387, 3.083, -30.796]}
          rotation={[-2.359, 0.205, 0.281]}
        />
        <mesh
          geometry={nodes.circularRoomPool_Baked.geometry}
          material={materials.mainCircularRoomPool_Baked}
          position={[-38.268, 0.16, -114.098]}
        />
        <mesh
          geometry={nodes.sculptureSorento_Baked.geometry}
          material={materials.mainCircularRoomPool_Baked}
          position={[-51.429, 0.004, -138.733]}
        />
        <mesh
          geometry={nodes.outdoorStairs_Baked.geometry}
          material={materials.outdoorStairs_Baked}
          position={[-61.17, 0, -133.453]}
          rotation={[0, 0.073, 0]}
        />
        <mesh
          geometry={nodes.archOutdoor_Baked.geometry}
          material={materials.arches_Baked}
          position={[-82.72, 9.846, -151.925]}
          rotation={[0, -0.7, 0]}
        />
        <mesh
          geometry={nodes.arch001_Baked.geometry}
          material={materials.arches_Baked}
          position={[-61.189, 0.957, -133.464]}
          rotation={[Math.PI / 2, 0, -0.871]}
        />
        <mesh
          geometry={nodes.canvasBack001.geometry}
          material={materials.canvasBack}
          position={[12.034, 3, -53.031]}
          rotation={[0, -0.422, 0]}
        />
        <mesh
          // geometry={nodes.circularRoomPoolWater.geometry}
          // material={materials.ocean}
          position={[-38.268, 0.26, -114.098]}
          rotation={nodes.circularRoomPoolWater.rotation}
          rotation-x={-Math.PI * 0.5}
        >
          <circleGeometry args={[15, 25]} />
          <MeshReflectorMaterial
            blur={[300, 100]}
            resolution={2048}
            mixBlur={1}
            mixStrength={50}
            roughness={0.2}
            depthScale={1.2}
            minDepthThreshold={0.4}
            maxDepthThreshold={1.4}
            color="#0f1112"
            metalness={0}
          />
        </mesh>
        <mesh
          geometry={nodes.sphere003.geometry}
          material={materials.sculpture}
          position={[3.486, 1.018, -107.404]}
        />
        <mesh
          geometry={nodes.columns.geometry}
          material={materials.benches}
          position={[16.643, 0, -35.363]}
        />
        <mesh
          geometry={nodes.canvas001.geometry}
          material={materials.Canvas01}
          position={[12.013, 3.027, -53.04]}
          rotation={[0, -0.422, 0]}
        />
        <mesh
          geometry={nodes.canvasBack002.geometry}
          material={materials.canvasBack}
          position={[-0.787, 3, -72.638]}
          rotation={[0, 0.42, 0]}
        />
        <mesh
          geometry={nodes.canvas002.geometry}
          material={materials.Canvas02}
          position={[-0.787, 3.028, -72.638]}
          rotation={[0, 0.42, 0]}
        />
        <mesh
          geometry={nodes.canvasBack003.geometry}
          material={materials.canvasBack}
          position={[10.63, 3, -92.398]}
          rotation={[0, -0.454, 0]}
        />
        <mesh
          geometry={nodes.canvas003.geometry}
          material={materials.Canvas03}
          position={[10.63, 3.03, -92.398]}
          rotation={[0, -0.454, 0]}
        />
        <mesh
          geometry={nodes.canvasBack004.geometry}
          material={materials.canvasBack}
          position={[-10.216, 3, -110.056]}
          rotation={[0, 0.556, 0]}
        />
        <mesh
          geometry={nodes.canvas004.geometry}
          material={materials.Canvas04}
          position={[-10.216, 3.038, -110.056]}
          rotation={[0, 0.556, 0]}
        />
        <mesh
          geometry={nodes.canvasBack005.geometry}
          material={materials.canvasBack}
          position={[-30.974, 3, -89.757]}
          rotation={[-Math.PI, 0.793, -Math.PI]}
        />
        <mesh
          geometry={nodes.canvas005.geometry}
          material={materials.Canvas05}
          position={[-30.974, 3.021, -89.757]}
          rotation={[-Math.PI, 0.793, -Math.PI]}
        />
        <mesh
          geometry={nodes.canvasBack006.geometry}
          material={materials.canvasBack}
          position={[-59.154, 3, -98.602]}
          rotation={[0, 1.476, 0]}
        />
        <mesh
          geometry={nodes.canvas006.geometry}
          material={materials.Canvas06}
          position={[-59.154, 3.028, -98.602]}
          rotation={[0, 1.476, 0]}
        />
        <mesh
          geometry={nodes.canvasBack007.geometry}
          material={materials.canvasBack}
          position={[-64.587, 3, -118.668]}
          rotation={[0, 0.714, 0]}
        />
        <mesh
          geometry={nodes.canvas007.geometry}
          material={materials.Canvas07}
          position={[-64.587, 3.039, -118.668]}
          rotation={[0, 0.714, 0]}
        />
        <mesh
          geometry={nodes.sphere002.geometry}
          material={materials.sculpture}
          position={[-3.167, 1.018, -55.319]}
        />
        <mesh
          geometry={nodes.sphere004.geometry}
          material={materials.sculpture}
          position={[-56.379, 1.018, -92.623]}
        />
        <mesh
          geometry={nodes.recessedLighting.geometry}
          material={materials.ringLight}
          position={[-38.268, 0.726, -114.098]}
          rotation={[0, -0.113, 0]}
        />
        <mesh
          geometry={nodes.benches.geometry}
          material={materials.benches}
          position={[-2.705, 0.235, -5.62]}
          rotation={[-Math.PI, 0, 0]}
        />
        <mesh
          geometry={nodes.sphere001.geometry}
          material={materials.sculpture}
          position={[16.34, 1.018, -34.641]}
        />
        <mesh
          geometry={nodes.outdoorWaterBarrier.geometry}
          material={materials.benches}
          position={[-38.623, -0.785, -159.184]}
          rotation={[0, -0.731, 0]}
        />
        <mesh
          geometry={nodes.human001.geometry}
          material={materials.logoSculpture}
          position={[6.714, -0.045, -14.873]}
          rotation={[Math.PI, -0.491, Math.PI]}
        />
        <mesh
          geometry={nodes.human002.geometry}
          material={materials.logoSculpture}
          position={[15.009, -0.045, -46.33]}
          rotation={[Math.PI, -0.302, Math.PI]}
        />
        <mesh
          geometry={nodes.human003.geometry}
          material={materials.logoSculpture}
          position={[-21.263, -0.045, -90.278]}
          rotation={[0, -1.34, 0]}
        />
        <mesh
          geometry={nodes.entranceRoofGlass.geometry}
          // material={materials['Roof Glass']}
          position={[0.892, 7.404, -8.343]}
        >
          <meshStandardMaterial
            color="#FFFFFF"
            // metalness={0.5}
            roughness={0}
            transparent
            opacity={0.2}
          />
        </mesh>
        <mesh
          geometry={nodes.island001.geometry}
          material={materials['rock.001']}
          position={[-250.715, 1.248, -296.708]}
          scale={36.713}
        />
        <mesh
          geometry={nodes.island002.geometry}
          material={materials['rock.001']}
          position={[-283.332, -0.972, -265.452]}
          rotation={[-Math.PI, 1.53, -Math.PI]}
          scale={28.756}
        />
        <mesh
          geometry={nodes.island003.geometry}
          material={materials['rock.001']}
          position={[-217.109, -0.27, -323.345]}
          rotation={[0, 1.5, 0]}
          scale={23.858}
        />
        <mesh
          geometry={nodes.island005.geometry}
          material={materials['rock.001']}
          position={[-140.402, -0.223, -40.052]}
          rotation={[0, -0.274, 0]}
          scale={42.645}
        />
        <mesh
          geometry={nodes.island004.geometry}
          material={materials['rock.001']}
          position={[-82.945, -1.914, -44.586]}
          rotation={[0, 1.252, 0]}
          scale={42.295}
        />
        <mesh
          geometry={nodes.island006.geometry}
          material={materials['rock.001']}
          position={[10.547, -0.223, -225.383]}
          rotation={[Math.PI, -0.988, Math.PI]}
          scale={36.713}
        />
        <mesh
          geometry={nodes.island008.geometry}
          material={materials['rock.001']}
          position={[106.985, -0.223, -147.611]}
          rotation={[0, -0.515, 0]}
          scale={36.713}
        />
        <mesh
          geometry={nodes.island007.geometry}
          material={materials['rock.001']}
          position={[22.29, -1.914, -185.296]}
          rotation={[0, -0.628, 0]}
          scale={42.295}
        />
        <mesh
          geometry={nodes.islandSphere.geometry}
          material={materials.sculpture}
          position={[-290.987, 7.529, -331.563]}
        />
        <mesh
          geometry={nodes.outdoorWaterBack.geometry}
          material={materials.ocean}
          position={[-120.208, 1.248, -184.074]}
          rotation={[0, -0.701, 0]}
        >
          {/* <MeshReflectorMaterial
            blur={[300, 100]}
            resolution={2048}
            mixBlur={1}
            mixStrength={50}
            roughness={0.2}
            depthScale={1.2}
            minDepthThreshold={0.4}
            maxDepthThreshold={1.4}
            color="#0f1112"
            metalness={0}
          /> */}
        </mesh>
        <mesh
          geometry={nodes.outdoorWaterFront.geometry}
          material={materials.ocean}
          position={[2.279, -0.019, -70.591]}
        />
        <mesh
          geometry={nodes.plantFrontGroup.geometry}
          material={materials['plant-1.001']}
          position={[-12.401, -0.097, -5.22]}
          rotation={[-1.017, -1.093, -0.963]}
        />
        <group position={[-39.903, 0.289, -119.987]} rotation={[0, -1.313, 0]}>
          <mesh
            geometry={nodes.Mesh045.geometry}
            material={materials['Leafs_Plante_01.001']}
          />
          <mesh
            geometry={nodes.Mesh045_1.geometry}
            material={materials['plant-1.001']}
          />
          <mesh
            geometry={nodes.Mesh045_2.geometry}
            material={materials['Leafs_Plante_04.002']}
          />
        </group>
        <mesh
          geometry={nodes.sphere005.geometry}
          material={materials.sculpture}
          position={[-64.611, 2.429, -140.891]}
        />
        <mesh
          geometry={nodes.sphere006.geometry}
          material={materials.sculpture}
          position={[-38.04, 15.327, -113.847]}
        />
      </group>
    </>
  );
}

{
  /* <mesh
  // geometry={nodes.circularRoomPoolWater.geometry}
  // material={materials.ocean}
  position={[-38.268, 0.26, -114.098]}
  rotation={nodes.circularRoomPoolWater.rotation}
  rotation-x={-Math.PI * 0.5}
>
  <circleGeometry args={[15, 25]} />
  <MeshReflectorMaterial
    blur={[300, 100]}
    resolution={2048}
    mixBlur={1}
    mixStrength={50}
    roughness={0.2}
    depthScale={1.2}
    minDepthThreshold={0.4}
    maxDepthThreshold={1.4}
    color="#0f1112"
    metalness={0}
  />
</mesh>; */
}

{
  /* <mesh
  receiveShadow
  rotation={[-Math.PI / 2, 0, 0]}
  position={[0.183, 0.015, -19.383]}
>
  <planeGeometry args={[300, 300]} />
  <MeshReflectorMaterial
    blur={1024}
    // blur={2048}
    resolution={1024}
    mixBlur={10}
    mixStrength={100}
    roughness={1}
    depthScale={1.2}
    minDepthThreshold={0.4}
    maxDepthThreshold={1.4}
    color="#212121"
    metalness={0.25}
    // map={floorTextureMap2}
    // normalMap={floorTextureMapNormal2}
    // normalMapType={THREE.ObjectSpaceNormalMap}
    // roughnessMap={floorTextureMapRoughness2}
    // bumpMap={floorTextureMap}
    aoMap={floorTextureMap}
    aoMapIntensity={2}
  />
</mesh> */
}

useGLTF.preload(MODEL_URL);

export default Model;
