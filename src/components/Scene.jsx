/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 portfolio03.glb 
*/

import React, { useEffect, useMemo, useRef, useState } from 'react';
import {
  MeshReflectorMaterial,
  PerspectiveCamera,
  useGLTF,
} from '@react-three/drei';
import { OrbitControls } from '../util/OrbitControlsCustom';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { render, useFrame, useThree } from '@react-three/fiber';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import {
  MeshBVH,
  MeshBVHHelper,
  StaticGeometryGenerator,
} from 'three-mesh-bvh';
import useKeyboard from '../hooks/useKeyboard';
import { useControls } from 'leva';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { create } from 'zustand';
import { ACTIONS, CharacterControls } from '../util/characterControls';
import { v4 as uuidv4 } from 'uuid';
import { Fluid } from '@alienkitty/alien.js/three';
import gsap from 'gsap';

import { loadCurveFromJSON } from '../util/curveTools/CurveMethods';

import videoSource from '/assets/video/zajno_showreel.mp4';
import floorTexture from '/assets/textures/cineshader_floor.jpeg';
import tileTexture from '/assets/textures/Tiles076_4K-JPG_Color.jpg';
import bakedFloor from '/assets/textures/baked/bakedFloor01.webp';
import floorTextureBaked01 from '/assets/textures/baked/floor001_Bake1_CyclesBake_COMBINED.png';
import cloudTexture01 from '/assets/textures/clouds/cloud1.jpg';
import cloudTexture02 from '/assets/textures/clouds/cloud2.jpg';
import cloudTexture03 from '/assets/textures/clouds/cloud3.jpg';
import Clouds from './Clouds';

var textureURL =
  'https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/lroc_color_poles_1k.jpg';
var displacementURL =
  'https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/ldem_3_8bit.jpg';
var worldURL = 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/hipp8_s.jpg';

const MODEL_URL = '/assets/models/portfolio06.glb';
const params = {
  firstPerson: true,
  displayCollider: false,
  displayBVH: false,
  visualizeDepth: 10,
  gravity: -50,
  playerWalkSpeed: 10, // 10
  playerRunSpeed: 50, // 25
  playerJumpHeight: 20,
  physicsSteps: 5,
  cameraOffsetY: 1.5,
  // startPosition: {
  //   // debug
  //   x: -2.59715775502132,
  //   y: -7.57213251605731,
  //   z: 7.25489462321836,
  // },
  startPosition: {
    // outdoors front
    x: 2,
    y: 10,
    z: 30.84643452606501,
  },
  // startPosition: {
  //   // outdoors back
  //   x: -75.87103553276128,
  //   y: 2,
  //   z: -41.36782889639384,
  // },
  // startPosition: {
  //   // indoors entrance
  //   x: 24.96,
  //   y: 20,
  //   z: 75.35,
  // },
  // startPosition: {
  //   // indoors entrance
  //   x: -38,
  //   y: 10,
  //   z: -110,
  // },
};

const LOOK_AT_POSITIONS = {
  START: {
    x: 2.413,
    y: 3.56651711467,
    z: -9.259,
  },
  SCULPTURE: {
    x: -5.41359,
    y: 3.56651711467,
    z: -30.5556,
  },
  C1: {
    x: 12.0733,
    y: 3.56651711467,
    z: -52.7959,
  },
  C2: {
    x: -0.946431,
    y: 3.56651711467,
    z: -72.4519,
  },
  C3: {
    x: 10.3668,
    y: 3.56651711467,
    z: -92.2975,
  },
  C4: {
    x: -10.1108,
    y: 3.56651711467,
    z: -110.121,
  },
  PLANT: {
    x: -30.9524,
    y: 3.56651711467,
    z: -107.544,
  },
  ROCK: {
    x: -37.8722,
    y: 3.56651711467,
    z: -114.15,
  },
  C5: {
    x: -31.094,
    y: 3.56651711467,
    z: -89.643,
  },
  C6: {
    x: -59.5351,
    y: 3.56651711467,
    z: -98.9969,
  },
  C7: {
    x: -64.5281,
    y: 3.56651711467,
    z: -118.526,
  },
  END: {
    x: -97.2037,
    y: 3.56651711467,
    z: -164.411,
  },
};

export const useStore = create((set) => ({
  animationsMap: new Map(),
  addAnimation: (key, value) =>
    set((state) => ({ animationsMap: state.animationsMap.set(key, value) })),
  mixer: new THREE.AnimationMixer(),
  orbitControls: null,
  setOrbitControls: (value) => set(() => ({ orbitControls: value })),
}));

function Model(props) {
  const [video] = useState(() => {
    const video = document.createElement('video');
    video.src = videoSource;
    video.loop = true;
    video.muted = true;
    video.autoplay = true;
    video.crossOrigin = 'anonymous';
    video.play();
    return video;
  });

  const { nodes: characterNodes, animations: characterAnimations } = useGLTF(
    '/assets/models/crypto03.glb'
  );

  const { scene, camera, gl } = useThree();
  const cameraGroup = useRef(null);
  const character = useRef(null);
  const mixer = useRef(null);
  const characterControls = useRef(null);
  const { animationsMap, addAnimation } = useStore();
  const { nodes, materials } = useGLTF(MODEL_URL);
  const { displayCollider, displayBVH, visualizeDepth, gravity } = useControls(
    'Scene',
    {
      displayCollider: false,
      displayBVH: false,
      visualizeDepth: { value: 10, min: 1, max: 20, step: 1 },
      gravity: { value: -30, min: -100, max: 100, step: 1 },
    },
    { collapsed: true }
  );

  // const skySphere = useRef(null);

  const scrollProgress = useRef(0);
  const cameraPositionPathData = useRef(null);
  const cameraLookAtPathData = useRef(null);

  const curvePosition = {
    x: 0,
    y: 1.5,
    z: 0,
  };
  // const curvePosition = {
  //   x: 2.1601,
  //   y: 2.0665,
  //   z: 0,
  // };
  // const curvePosition = {
  //   x: 2.1601,
  //   y: 2.0665,
  //   z: 44.755,
  // };

  useEffect(() => {
    const loadCameraPositionData = async () => {
      const JSONPath = '/assets/models/cameraPosition.json';
      const data = await loadCurveFromJSON(JSONPath, 0xff0000);
      // const curvePosition = nodes.cameraPosition.position;
      data.mesh.position.set(curvePosition.x, curvePosition.y, curvePosition.z);
      // scene.add(data.mesh);
      cameraPositionPathData.current = data;
    };
    loadCameraPositionData();
    const loadCameraLookAtData = async () => {
      const JSONPath = '/assets/models/cameraLookAt.json';
      const data = await loadCurveFromJSON(JSONPath, 0xff0000);
      // const curvePosition = nodes.cameraPosition.position;
      data.mesh.position.set(curvePosition.x, curvePosition.y, curvePosition.z);
      // scene.add(data.mesh);
      cameraLookAtPathData.current = data;
    };
    loadCameraLookAtData();
  }, []);

  useEffect(() => {
    const handleScroll = (e) => {
      scrollProgress.current =
        window.scrollY / (document.body.scrollHeight - window.innerHeight);
      console.log(scrollProgress.current);
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  const rotationTarget = useRef({ x: 0, y: 0, z: 0 });

  useEffect(() => {
    // PARALLAX EFFECT
    const handleMouseMove = (e) => {
      const x = e.clientX / window.innerWidth - 0.5;
      const y = e.clientY / window.innerHeight - 0.5;

      rotationTarget.current.y = -x * 1;
      rotationTarget.current.x = -y * 1;
    };

    window.addEventListener('mousemove', handleMouseMove);

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);

  // const { iterate, density, velocity, pressure, curl, radius } = useControls(
  //   'Fluid',
  //   {
  //     iterate: { value: 3, min: 1, max: 10 },
  //     density: { value: 0.95, min: 0, max: 1 },
  //     velocity: { value: 0.98, min: 0, max: 1 },
  //     pressure: { value: 0.8, min: 0, max: 1 },
  //     curl: { value: 2.5, min: 0, max: 50 },
  //     radius: { value: 0.3, min: 0.01, max: 0.5 },
  //   },
  //   { collapsed: true }
  // );
  // const canvas01 = useRef(null);
  // const canvas02 = useRef(null);
  // const canvas03 = useRef(null);
  // const canvas04 = useRef(null);
  // const canvas05 = useRef(null);
  // const canvas06 = useRef(null);
  // const canvas07 = useRef(null);
  // const mouse = useRef({
  //   world: new THREE.Vector2(),
  //   uv: new THREE.Vector2(),
  //   isInit: false,
  // });
  // const raycaster = new THREE.Raycaster();
  // const fluid = useRef(
  //   new Fluid(gl, {
  //     curlStrength: 0,
  //   })
  // );

  // useEffect(() => {
  //   const fluidInstance = fluid.current;

  //   return () => {
  //     fluidInstance.destroy();
  //   };
  // }, []);

  // useEffect(() => {
  //   const handleMouseMove = (e) => {
  //     // if pointer is down, don't do anything
  //     // if (e.buttons) return;
  //     const event = {
  //       x: (e.clientX / window.innerWidth) * 2 - 1,
  //       y: -(e.clientY / window.innerHeight) * 2 + 1,
  //     };

  //     if (!mouse.current.isInit) {
  //       mouse.current.isInit = true;
  //       mouse.current.world.copy(event);
  //       mouse.current.uv.copy(event);
  //     }

  //     // console.log(mouse.current.world, mouse.current.uv);
  //     raycaster.setFromCamera(mouse.current.world, camera);
  //     const intersects = raycaster.intersectObjects([
  //       canvas01.current,
  //       canvas02.current,
  //       canvas03.current,
  //       canvas04.current,
  //       canvas05.current,
  //       canvas06.current,
  //       canvas07.current,
  //     ]);

  //     // console.log('intersects: ', intersects);
  //     if (intersects.length > 0) {
  //       const { x, y } = intersects[0].uv;

  //       const deltaX = x - mouse.current.uv.x;
  //       const deltaY = y - mouse.current.uv.y;

  //       mouse.current.uv.copy(intersects[0].uv);

  //       if (Math.abs(deltaX) || Math.abs(deltaY)) {
  //         // console.log(x, y, deltaX, deltaY);
  //         if (fluid.current) {
  //           fluid.current.splats.push({
  //             x: x,
  //             y: y,
  //             dx: deltaX * 5000,
  //             dy: deltaY * 5000,
  //           });
  //         }
  //       }
  //     }

  //     mouse.current.world.copy(event);
  //   };

  //   window.addEventListener('mousemove', handleMouseMove);

  //   return () => {
  //     window.removeEventListener('mousemove', handleMouseMove);
  //   };
  // }, []);

  const isFirstPerson = useRef(true);
  const [{ firstPerson }, setFirstPerson] = useControls('Scene', () => ({
    firstPerson: true,
  }));

  const loader = useMemo(() => {
    const loader = new GLTFLoader();
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(dracoLoader);
    return loader;
  }, []);

  const [isSceneReady, setSceneReady] = useState(false);
  const world = useRef(null);
  const collider = useRef(null);
  const visualizer = useRef(null);
  const controls = useRef(null);
  const player = useRef(null);
  const keyboard = useKeyboard();
  const playerIsOnGround = useRef(false);
  const playerVelocity = useMemo(() => new THREE.Vector3(), []);
  const upVector = useMemo(() => new THREE.Vector3(0, 1, 0), []);
  const tempVector = useMemo(() => new THREE.Vector3(), []);
  const tempVector2 = useMemo(() => new THREE.Vector3(), []);
  const tempBox = useMemo(() => new THREE.Box3(), []);
  const tempMat = useMemo(() => new THREE.Matrix4(), []);
  const tempSegment = useMemo(() => new THREE.Line3(), []);

  // useEffect(() => {
  //   mixer.current = new THREE.AnimationMixer(character.current);

  //   characterAnimations.forEach((clip) => {
  //     const action = mixer.current.clipAction(clip);
  //     if (clip.name === 'Jumping') {
  //       action.setLoop(THREE.LoopOnce);
  //       action.timeScale = 0.5;
  //     } else {
  //       action.timeScale = 1.25;
  //     }
  //     addAnimation(clip.name, action);
  //   });
  // }, []);

  // useEffect(() => {
  //   if (controls.current && animationsMap && camera && mixer.current) {
  //     characterControls.current = new CharacterControls(
  //       character.current,
  //       player.current,
  //       mixer.current,
  //       animationsMap,
  //       controls.current,
  //       camera,
  //       ACTIONS.IDLE
  //     );
  //   }
  // }, [animationsMap, camera]);

  // useEffect(() => {
  //   const gltfScene = world.current;

  //   const box = new THREE.Box3();
  //   box.setFromObject(gltfScene);
  //   box.getCenter(gltfScene.position).negate();
  //   // console.log(box);
  //   gltfScene.updateMatrixWorld(true);

  //   const staticGenerator = new StaticGeometryGenerator(gltfScene);
  //   staticGenerator.attributes = ['position'];

  //   const mergedGeometry = staticGenerator.generate();
  //   mergedGeometry.boundsTree = new MeshBVH(mergedGeometry);

  //   collider.current = new THREE.Mesh(mergedGeometry);
  //   collider.current.material.wireframe = true;
  //   collider.current.material.opacity = 0.5;
  //   collider.current.material.transparent = true;

  //   visualizer.current = new MeshBVHHelper(
  //     collider.current,
  //     params.visualizeDepth
  //   );

  //   scene.add(visualizer.current);
  //   scene.add(collider.current);
  //   setSceneReady(true);

  //   return () => {
  //     if (collider.current) {
  //       scene.remove(collider.current);
  //     }
  //     if (visualizer.current) {
  //       scene.remove(visualizer.current);
  //     }
  //   };
  // }, [loader, scene]);

  // useEffect(() => {
  //   if (!isSceneReady) return;
  //   if (player.current) {
  //     scene.remove(player.current);
  //   }
  //   const radius = 0.5;
  //   const playerCapsule = new THREE.Mesh(
  //     new RoundedBoxGeometry(radius * 2, 2.0, radius * 2, 10, 0.5),
  //     new THREE.MeshBasicMaterial({
  //       transparent: true,
  //       opacity: 0,
  //       // color: 'white',
  //       wireframe: false,
  //       depthTest: false,
  //       depthWrite: false,
  //     })
  //   );

  //   // const axesHelper = new THREE.AxesHelper(1);
  //   // playerCapsule.add(axesHelper);

  //   const group = new THREE.Group();
  //   group.add(playerCapsule);
  //   group.add(character.current);
  //   player.current = group;

  //   playerCapsule.geometry.translate(0, -radius, 0);
  //   character.current.position.set(0, -radius * 3, 0);
  //   // player.current.position.set(0, 10, 0);
  //   // player.current.position.set(15.75, -3, 30);
  //   player.current.position.set(
  //     params.startPosition.x,
  //     params.startPosition.y,
  //     params.startPosition.z
  //   );
  //   player.current.capsuleInfo = {
  //     radius: radius,
  //     segment: new THREE.Line3(
  //       new THREE.Vector3(),
  //       new THREE.Vector3(0, -1.0, 0.0)
  //     ),
  //   };
  //   // player.current.castShadow = true;
  //   // player.current.receiveShadow = true;
  //   // player.current.material.shadowSide = 2;
  //   scene.add(group);
  //   reset();
  // }, [isSceneReady]);

  // useEffect(() => {
  //   // if (!controls.current) return;
  //   if (firstPerson) {
  //     controls.current.maxPolarAngle = Math.PI;
  //     controls.current.minDistance = 1e-4;
  //     controls.current.maxDistance = 1e-4;
  //   } else {
  //     camera.position
  //       .sub(controls.current.target)
  //       .normalize()
  //       .multiplyScalar(8)
  //       .add(controls.current.target);

  //     controls.current.maxPolarAngle = Math.PI * 0.55;
  //     controls.current.minDistance = 2;
  //     controls.current.maxDistance = 10;
  //   }
  // }, [camera.position, firstPerson, isSceneReady]);

  // const reset = () => {
  //   playerVelocity.set(0, 0, 0);
  //   // player.current.position.set(0, 20, 0);
  //   player.current.position.set(
  //     params.startPosition.x,
  //     params.startPosition.y,
  //     params.startPosition.z
  //   );
  //   camera.position.sub(controls.current.target);
  //   controls.current.target.copy(player.current.position);
  //   camera.position.add(player.current.position);
  //   controls.current.update();
  // };

  // function updatePlayer(delta) {
  //   if (playerIsOnGround.current) {
  //     playerVelocity.y = delta * gravity;
  //   } else {
  //     playerVelocity.y += delta * gravity;
  //   }

  //   player.current.position.addScaledVector(playerVelocity, delta);

  //   // console.log(player.current.position);
  //   // move the player
  //   const angle = controls.current.getAzimuthalAngle() || 0;
  //   const shift = keyboard['ShiftLeft'] || keyboard['ShiftRight'];

  //   if (keyboard['KeyW']) {
  //     tempVector.set(0, 0, -1).applyAxisAngle(upVector, angle);
  //     player.current.position.addScaledVector(
  //       tempVector,
  //       delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
  //     );
  //   }

  //   if (keyboard['KeyS']) {
  //     tempVector.set(0, 0, 1).applyAxisAngle(upVector, angle);
  //     player.current.position.addScaledVector(
  //       tempVector,
  //       delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
  //     );
  //   }

  //   if (keyboard['KeyA']) {
  //     tempVector.set(-1, 0, 0).applyAxisAngle(upVector, angle);
  //     player.current.position.addScaledVector(
  //       tempVector,
  //       delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
  //     );
  //   }

  //   if (keyboard['KeyD']) {
  //     tempVector.set(1, 0, 0).applyAxisAngle(upVector, angle);
  //     player.current.position.addScaledVector(
  //       tempVector,
  //       delta * (shift ? params.playerRunSpeed : params.playerWalkSpeed)
  //     );
  //   }

  //   player.current.updateMatrixWorld();

  //   // adjust player position based on collisions
  //   const capsuleInfo = player.current.capsuleInfo;
  //   tempBox.makeEmpty();
  //   tempMat.copy(collider.current.matrixWorld).invert();
  //   tempSegment.copy(capsuleInfo.segment);

  //   // get the position of the capsule in the local space of the collider
  //   tempSegment.start
  //     .applyMatrix4(player.current.matrixWorld)
  //     .applyMatrix4(tempMat);
  //   tempSegment.end
  //     .applyMatrix4(player.current.matrixWorld)
  //     .applyMatrix4(tempMat);

  //   // get the axis aligned bounding box of the capsule
  //   tempBox.expandByPoint(tempSegment.start);
  //   tempBox.expandByPoint(tempSegment.end);

  //   tempBox.min.addScalar(-capsuleInfo.radius);
  //   tempBox.max.addScalar(capsuleInfo.radius);

  //   collider.current.geometry.boundsTree.shapecast({
  //     intersectsBounds: (box) => box.intersectsBox(tempBox),

  //     intersectsTriangle: (tri) => {
  //       // check if the triangle is intersecting the capsule and adjust the
  //       // capsule position if it is.
  //       const triPoint = tempVector;
  //       const capsulePoint = tempVector2;

  //       const distance = tri.closestPointToSegment(
  //         tempSegment,
  //         triPoint,
  //         capsulePoint
  //       );
  //       if (distance < capsuleInfo.radius) {
  //         const depth = capsuleInfo.radius - distance;
  //         const direction = capsulePoint.sub(triPoint).normalize();

  //         tempSegment.start.addScaledVector(direction, depth);
  //         tempSegment.end.addScaledVector(direction, depth);
  //       }
  //     },
  //   });

  //   // get the adjusted position of the capsule collider in world space after checking
  //   // triangle collisions and moving it. capsuleInfo.segment.start is assumed to be
  //   // the origin of the player model.
  //   const newPosition = tempVector;
  //   newPosition
  //     .copy(tempSegment.start)
  //     .applyMatrix4(collider.current.matrixWorld);

  //   // check how much the collider was moved
  //   const deltaVector = tempVector2;
  //   deltaVector.subVectors(newPosition, player.current.position);

  //   // if the player was primarily adjusted vertically we assume it's on something we should consider ground
  //   playerIsOnGround.current =
  //     deltaVector.y > Math.abs(delta * playerVelocity.y * 0.25);

  //   const offset = Math.max(0.0, deltaVector.length() - 1e-5);
  //   deltaVector.normalize().multiplyScalar(offset);

  //   // adjust the player model
  //   player.current.position.add(deltaVector);

  //   if (!playerIsOnGround.current) {
  //     deltaVector.normalize();
  //     playerVelocity.addScaledVector(
  //       deltaVector,
  //       -deltaVector.dot(playerVelocity)
  //     );
  //   } else {
  //     playerVelocity.set(0, 0, 0);
  //   }

  //   // adjust the camera
  //   camera.position.sub(controls.current.target);
  //   const newTarget = player.current.position.clone();
  //   newTarget.y += params.cameraOffsetY;
  //   controls.current.target.copy(newTarget);
  //   camera.position.add(newTarget);

  //   // if the player has fallen too far below the level reset their position to the start
  //   if (player.current.position.y < -25) {
  //     reset();
  //   }
  // }

  // useEffect(() => {
  //   const handleKeyDown = (event) => {
  //     if (keyboard['ShiftLeft'] && keyboard['KeyF']) {
  //       setFirstPerson({ firstPerson: isFirstPerson.current ? false : true });
  //       isFirstPerson.current = !isFirstPerson.current;
  //     }
  //   };

  //   window.addEventListener('keydown', handleKeyDown);
  //   return () => window.removeEventListener('keydown', handleKeyDown);
  // }, []);

  // useEffect(() => {
  //   console.log(nodes.circularRoomPoolWater);
  // }, []);

  const videoTexture = useMemo(() => {
    const texture = new THREE.VideoTexture(video);
    // texture.minFilter = THREE.LinearFilter;
    // texture.magFilter = THREE.LinearFilter;
    // texture.format = THREE.RGBFormat;
    texture.flipY = false;
    return texture;
  }, [video]);

  const floorBakedTexture = useMemo(() => {
    const texture = new THREE.TextureLoader().load(bakedFloor);
    // texture.flipY = false;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;

    return texture;
  }, []);

  const floorTextureMap = useMemo(() => {
    const texture = new THREE.TextureLoader().load(floorTexture);
    texture.flipY = false;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(25, 25);
    return texture;
  }, []);

  const moonTexture = useMemo(() => {
    const texture = new THREE.TextureLoader().load(textureURL);
    texture.flipY = false;
    return texture;
  }, []);

  const moonDisplacementTexture = useMemo(() => {
    const texture = new THREE.TextureLoader().load(displacementURL);
    texture.flipY = false;
    return texture;
  }, []);

  const uniforms = useMemo(
    () => ({
      uTime: { value: 0 },
      uVideoTexture: { value: videoTexture },
      uFluid: { value: null },
      // uRGBShift: { value: 1 },
    }),
    []
  );

  const shaderMaterial = useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: `
        varying vec2 vUv;

        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform sampler2D uVideoTexture;
        uniform sampler2D uFluid;
        // uniform int uRGBShift;

        varying vec2 vUv;

        void main() {
          vec3 fluid = texture2D(uFluid, vUv).rgb;
          vec2 uv = vUv;
          vec2 uv2 = vUv - (fluid.xy * .001);
          vec4 color = texture2D(uVideoTexture, uv2);
          // vec3 rgb = fluid * 0.0001;

          // color.r = texture2D(uVideoTexture, vec2(uv.x+rgb.x, uv.y+rgb.y)).r;
          // color.g = texture2D(uVideoTexture, vec2(uv.x-rgb.x, uv.y+rgb.y)).g;
          // color.b = texture2D(uVideoTexture, vec2(uv.x-rgb.x, uv.y-rgb.y)).b;
          gl_FragColor = color;
          // gl_FragColor = vec4(vUv, 1.0, 1.0);
        }
      `,
    });
  }, []);

  const getLookAtPosition = (scrollProgress) => {
    let key = 'START';
    if (scrollProgress < 0.045) {
      key = 'START';
    } else if (scrollProgress < 0.08) {
      key = 'SCULPTURE';
    } else if (scrollProgress < 0.18) {
      key = 'C1';
    } else if (scrollProgress < 0.285) {
      key = 'C2';
    } else if (scrollProgress < 0.37) {
      key = 'C3';
    } else if (scrollProgress < 0.45) {
      key = 'C4';
    } else if (scrollProgress < 0.49) {
      key = 'PLANT';
    } else if (scrollProgress < 0.6) {
      key = 'C5';
    } else if (scrollProgress < 0.686) {
      key = 'C6';
    } else if (scrollProgress < 0.77) {
      key = 'C7';
    } else if (scrollProgress < 0.88) {
      key = 'ROCK';
      // key = 'END';
    } else {
      key = 'END';
    }
    return key;
  };

  const newLookAtPosition = useRef(
    new THREE.Vector3(
      LOOK_AT_POSITIONS.START.x,
      LOOK_AT_POSITIONS.START.y,
      LOOK_AT_POSITIONS.START.z
    )
  );

  const rotationMatrix = new THREE.Matrix4();
  const targetQuarternion = new THREE.Quaternion();

  useFrame((state, delta) => {
    // if (collider.current) {
    //   collider.current.visible = displayCollider;
    //   visualizer.current.visible = displayBVH;
    //   visualizer.current.depth = visualizeDepth;
    //   visualizer.current.update();
    // }
    // if (collider.current && player.current) {
    //   for (let i = 0; i < params.physicsSteps; i++) {
    //     updatePlayer(delta / params.physicsSteps);
    //   }
    // }

    // if (keyboard['Space'] && playerIsOnGround.current) {
    //   playerVelocity.y = params.playerJumpHeight;
    //   playerIsOnGround.current = false;
    // }

    // if (characterControls.current) {
    //   characterControls.current.update(
    //     delta,
    //     keyboard,
    //     playerIsOnGround.current
    //   );
    // }

    // update uTime uniform
    uniforms.uTime.value = state.clock.elapsedTime;

    // if (fluid.current) {
    //   if (fluid.current.uniform) {
    //     canvas01.current.material.uniforms.uFluid.value =
    //       fluid.current.uniform.value;
    //   }

    //   fluid.current.iterate = iterate;
    //   fluid.current.densityDissipation = density;
    //   fluid.current.velocityDissipation = velocity;
    //   fluid.current.pressureDissipation = pressure;
    //   fluid.current.curlStrength = curl;
    //   fluid.current.radius = radius;
    //   fluid.current.update();
    // }

    // if (cubeCamera) {
    //   cubeCamera.update(gl, scene);
    // }

    if (cameraPositionPathData.current && cameraLookAtPathData.current) {
      const curve = cameraPositionPathData.current.curve;
      const point = curve.getPoint(scrollProgress.current);
      // points are relative to curve global position so we need to add the camera position
      point.add(curvePosition);

      // gsap.to(cameraGroup.current.position, {
      //   x: point.x,
      //   y: point.y,
      //   z: point.z,
      //   duration: 0.75,
      // });
      gsap.to(camera.position, {
        x: point.x - rotationTarget.current.y,
        y: point.y + rotationTarget.current.x,
        z: point.z,
        duration: 0.75,
      });

      const lookAtKey = getLookAtPosition(scrollProgress.current);
      const lookAtPosition = LOOK_AT_POSITIONS[lookAtKey];

      // const newLookAtPosition = new THREE.Vector3();

      // gsap.to(newLookAtPosition.current, {
      //   x: lookAtPosition.x,
      //   y: lookAtPosition.y,
      //   z: lookAtPosition.z,
      //   duration: 1,
      //   onUpdate: () => {
      //     camera.lookAt(newLookAtPosition.current);
      //   },
      // });

      // const target = cameraGroup.current.clone();
      const target = camera.clone();
      target.lookAt(
        new THREE.Vector3(lookAtPosition.x, lookAtPosition.y, lookAtPosition.z)
      );

      // rotate camera group 180 degrees to face the right direction
      // cameraGroup.current.rotation.y = Math.PI;
      // camera.quaternion.slerp(target.quaternion, 0.05);

      // // log the camera forward vector
      // const forward = new THREE.Vector3(0, 0, -1);
      // forward.applyQuaternion(camera.quaternion);

      // based on the forward vector, rotate camera left/right/up/down based on mouse movement variable rotationTarget
      // const rotationMatrix = new THREE.Matrix4();
      // const targetQuarternion = new THREE.Quaternion();
      // rotationMatrix.makeRotationFromEuler(
      //   new THREE.Euler(
      //     rotationTarget.current.x,
      //     rotationTarget.current.y,
      //     rotationTarget.current.z
      //   )
      // );
      // targetQuarternion.setFromRotationMatrix(rotationMatrix);
      // camera.quaternion.slerp(targetQuarternion, 0.05);

      camera.quaternion.slerp(target.quaternion, 0.025);
      // cameraGroup.current.quaternion.slerp(target.quaternion, 0.025);

      // if (rotationTarget.current) {
      //   // rotate scene based on mouse movement for parallax effect
      //   gsap.to(world.current.rotation, {
      //     x: rotationTarget.current.x,
      //     y: rotationTarget.current.y,
      //     z: rotationTarget.current.z,
      //     duration: 0.5,
      //   });
      // }
    }

    // sync camera rotation with cameraGroup rotation
    // camera.quaternion.copy(cameraGroup.current.quaternion);
  });

  const waterBack = useRef(null);

  useEffect(() => {
    if (waterBack.current) {
      // rotate the water back plane
      // waterBack.current.rotation.y = 0;
      waterBack.current.rotation.x = -Math.PI * 0.5;
    }
  }, []);

  const floorTexture01 = useMemo(() => {
    const texture = new THREE.TextureLoader().load(floorTextureBaked01);
    texture.flipY = false;
    return texture;
  }, []);

  const characterGroup = (
    <group ref={character} {...props} dispose={null}>
      <group name="Scene">
        <group
          name="Armature"
          rotation={[Math.PI / 2, 0, Math.PI]}
          scale={0.011}
        >
          <primitive object={characterNodes.mixamorig1Hips} />
          <skinnedMesh
            name="Ch45"
            geometry={characterNodes.Ch45.geometry}
            // material={characterMaterials.Ch45_Body}
            skeleton={characterNodes.Ch45.skeleton}
            castShadow
            receiveShadow
          >
            {/* <meshLambertMaterial /> */}
            <meshStandardMaterial
              color="white"
              // map={videoTexture}
              roughness={0}
              metalness={1}
              emissive={'#ddd'}
              emissiveIntensity={0.3}
              wireframe={true}
              wireframeLinewidth={0.1}
            />
            {/* <meshToonMaterial color="white" /> */}
            {/* <meshMatcapMaterial /> */}
            {/* <meshStandardMaterial
                color="white"
                map={videoTexture}
                roughness={1}
              /> */}
          </skinnedMesh>
        </group>
      </group>
    </group>
  );

  return (
    <>
      {/* <OrbitControls
        ref={controls}
        mouseButtons={{
          LEFT: THREE.MOUSE.ROTATE,
          RIGHT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.ROTATE,
        }}
      /> */}
      <Clouds />

      <group ref={cameraGroup}>
        <PerspectiveCamera
          makeDefault
          // ref={camera}
          fov={75}
          aspect={window.innerWidth / window.innerHeight}
          near={0.1}
          far={2000}
          // far={300}
          zoom={1}
          // position={[0, 1.5, 0]}
        />
      </group>
      <group ref={world} {...props} dispose={null}>
        <group
          position={[-81.585, 1.546, -155.711]}
          rotation={[-Math.PI / 2, 0, 0]}
        >
          <group rotation={[Math.PI / 2, 0, 0]}>
            <group position={[-0.301, -0.125, -0.095]}>
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0.geometry}
                material={materials.pine_2_1Mat}
              />
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0_1.geometry}
                material={materials.trunk_2_1_0Mat}
              />
            </group>
            <group
              position={[-5.016, -0.125, 5.02]}
              rotation={[-Math.PI, 0.425, -Math.PI]}
            >
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0003.geometry}
                material={materials.pine_2_1Mat}
              />
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0003_1.geometry}
                material={materials.trunk_2_1_0Mat}
              />
            </group>
          </group>
        </group>
        <mesh
          geometry={nodes.rockGroup_Baked.geometry}
          material={materials.rockGroup_Baked}
          position={[-38.04, 0.134, -113.847]}
          rotation={[1.81, 0.887, 2.375]}
        />
        <mesh
          geometry={nodes.entranceWalls_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[0, -0.028, -13.737]}
        />
        <mesh
          geometry={nodes.entranceCurvedWall_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[-6.25, 4.315, -18.294]}
        />
        <mesh
          geometry={nodes.entranceRoof_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[-0.001, 3.242, -13.737]}
        />
        <mesh
          geometry={nodes.entranceRoofWindows_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[2.223, 7.458, -8.255]}
        />
        <mesh
          geometry={nodes.entranceCurvedRoomPedestal_Baked.geometry}
          material={materials.entranceFloorAndPedestal_Baked}
          position={[-5.211, 0.496, -30.827]}
        />
        <mesh
          geometry={nodes.floor001_Baked.geometry}
          material={materials.entranceFloorAndPedestal_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.entranceCurvedRoom_Baked.geometry}
          material={materials.entranceRoundWalls_Baked}
          position={[-4.383, 5.782, -31.047]}
        />
        <mesh
          geometry={nodes.entranceCurvedRoomTop_Baked.geometry}
          material={materials.entranceRoundWalls_Baked}
          position={[-1.632, 9.146, -30.827]}
        />
        <mesh
          geometry={nodes.mainRoomTop001_Baked.geometry}
          material={materials.mainHallFloorAndTop_Baked}
          position={[6.161, 16.353, -65.066]}
        />
        <mesh
          geometry={nodes.mainRoomWalls_Baked.geometry}
          material={materials.mainHallWalls_Baked}
          position={[6.191, -0.001, -41.53]}
        />
        <mesh
          geometry={nodes.mainRoomTop002_Baked.geometry}
          material={materials.mainHallWalls_Baked}
          position={[0.682, 16.351, -97.22]}
        />
        <mesh
          geometry={nodes.floor003_Baked.geometry}
          material={materials.floor003_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.floor003001_Baked.geometry}
          material={materials.mainCircularRoomFloors_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.floor003002_Baked.geometry}
          material={materials.mainCircularRoomFloors_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.circularRoom_Baked.geometry}
          material={materials.circularRoom_Baked}
          position={[-38.268, 0.726, -114.098]}
          rotation={[0, -0.113, 0]}
        />
        <mesh
          geometry={nodes.circularRoomTop_Baked.geometry}
          material={materials.circularRoomTop_Baked}
          position={[-38.268, 18.336, -114.098]}
        />
        <mesh
          geometry={nodes.floor002_Baked.geometry}
          material={materials.floor002_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.logoSculpture_Baked.geometry}
          material={materials.logoSculpture_Baked}
          position={[-5.387, 3.083, -30.796]}
          rotation={[-2.359, 0.205, 0.281]}
        />
        <mesh
          geometry={nodes.circularRoomPool_Baked.geometry}
          material={materials.mainCircularRoomPool_Baked}
          position={[-38.268, 0.16, -114.098]}
        />
        <mesh
          geometry={nodes.sculptureSorento_Baked.geometry}
          material={materials.mainCircularRoomPool_Baked}
          position={[-51.429, 0.004, -138.733]}
        />
        <mesh
          geometry={nodes.outdoorStairs_Baked.geometry}
          material={materials.outdoorStairs_Baked}
          position={[-61.17, 0, -133.453]}
          rotation={[0, 0.073, 0]}
        />
        <mesh
          geometry={nodes.archOutdoor_Baked.geometry}
          material={materials.arches_Baked}
          position={[-82.72, 9.846, -151.925]}
          rotation={[0, -0.7, 0]}
        />
        <mesh
          geometry={nodes.arch001_Baked.geometry}
          material={materials.arches_Baked}
          position={[-61.189, 0.957, -133.464]}
          rotation={[Math.PI / 2, 0, -0.871]}
        />
        <mesh
          geometry={nodes.canvasBack001.geometry}
          material={materials.canvasBack}
          position={[12.034, 3, -53.031]}
          rotation={[0, -0.422, 0]}
        />
        <mesh
          // geometry={nodes.circularRoomPoolWater.geometry}
          // material={materials.ocean}
          position={[-38.268, 0.26, -114.098]}
          rotation={nodes.circularRoomPoolWater.rotation}
          rotation-x={-Math.PI * 0.5}
        >
          <circleGeometry args={[15, 25]} />
          <MeshReflectorMaterial
            // blur={[300, 100]}
            // resolution={2048}
            // mixBlur={1}
            // mixStrength={50}
            // roughness={0.2}
            // depthScale={1.2}
            // minDepthThreshold={0.4}
            // maxDepthThreshold={1.4}
            // color="#0f1112"
            // metalness={0}
            blur={[300, 100]}
            resolution={2048}
            mixBlur={1}
            mixStrength={50}
            roughness={0.2}
            depthScale={1.2}
            minDepthThreshold={0.4}
            maxDepthThreshold={1.4}
            color="#0f1112"
            metalness={0}
          />
        </mesh>
        <mesh
          geometry={nodes.sphere003.geometry}
          material={materials.sculpture}
          position={[3.486, 1.018, -107.404]}
        />
        <mesh
          geometry={nodes.columns.geometry}
          material={materials.benches}
          position={[16.643, 0, -35.363]}
        />
        <mesh
          geometry={nodes.canvas001.geometry}
          material={materials.Canvas01}
          position={[12.013, 3.027, -53.04]}
          rotation={[0, -0.422, 0]}
        />
        <mesh
          geometry={nodes.canvasBack002.geometry}
          material={materials.canvasBack}
          position={[-0.787, 3, -72.638]}
          rotation={[0, 0.42, 0]}
        />
        <mesh
          geometry={nodes.canvas002.geometry}
          material={materials.Canvas02}
          position={[-0.787, 3.028, -72.638]}
          rotation={[0, 0.42, 0]}
        />
        <mesh
          geometry={nodes.canvasBack003.geometry}
          material={materials.canvasBack}
          position={[10.63, 3, -92.398]}
          rotation={[0, -0.454, 0]}
        />
        <mesh
          geometry={nodes.canvas003.geometry}
          material={materials.Canvas03}
          position={[10.63, 3.03, -92.398]}
          rotation={[0, -0.454, 0]}
        />
        <mesh
          geometry={nodes.canvasBack004.geometry}
          material={materials.canvasBack}
          position={[-10.216, 3, -110.056]}
          rotation={[0, 0.556, 0]}
        />
        <mesh
          geometry={nodes.canvas004.geometry}
          material={materials.Canvas04}
          position={[-10.216, 3.038, -110.056]}
          rotation={[0, 0.556, 0]}
        />
        <mesh
          geometry={nodes.canvasBack005.geometry}
          material={materials.canvasBack}
          position={[-30.974, 3, -89.757]}
          rotation={[-Math.PI, 0.793, -Math.PI]}
        />
        <mesh
          geometry={nodes.canvas005.geometry}
          material={materials.Canvas05}
          position={[-30.974, 3.021, -89.757]}
          rotation={[-Math.PI, 0.793, -Math.PI]}
        />
        <mesh
          geometry={nodes.canvasBack006.geometry}
          material={materials.canvasBack}
          position={[-59.154, 3, -98.602]}
          rotation={[0, 1.476, 0]}
        />
        <mesh
          geometry={nodes.canvas006.geometry}
          material={materials.Canvas06}
          position={[-59.154, 3.028, -98.602]}
          rotation={[0, 1.476, 0]}
        />
        <mesh
          geometry={nodes.canvasBack007.geometry}
          material={materials.canvasBack}
          position={[-64.587, 3, -118.668]}
          rotation={[0, 0.714, 0]}
        />
        <mesh
          geometry={nodes.canvas007.geometry}
          material={materials.Canvas07}
          position={[-64.587, 3.039, -118.668]}
          rotation={[0, 0.714, 0]}
        />
        <mesh
          geometry={nodes.sphere002.geometry}
          material={materials.sculpture}
          position={[-3.167, 1.018, -55.319]}
        />
        <mesh
          geometry={nodes.sphere004.geometry}
          material={materials.sculpture}
          position={[-56.379, 1.018, -92.623]}
        />
        <mesh
          geometry={nodes.recessedLighting.geometry}
          material={materials.ringLight}
          position={[-38.268, 0.726, -114.098]}
          rotation={[0, -0.113, 0]}
        />
        <mesh
          geometry={nodes.benches.geometry}
          material={materials.benches}
          position={[-2.705, 0.235, -5.62]}
          rotation={[-Math.PI, 0, 0]}
        />
        <mesh
          geometry={nodes.sphere001.geometry}
          material={materials.sculpture}
          position={[16.34, 1.018, -34.641]}
        />
        {/* <mesh
          geometry={nodes.outdoorWaterBarrier.geometry}
          material={materials.benches}
          position={[-38.623, -0.785, -159.184]}
          rotation={[0, -0.731, 0]}
        /> */}
        <mesh
          geometry={nodes.human001.geometry}
          material={materials.logoSculpture}
          position={[6.714, -0.045, -14.873]}
          rotation={[Math.PI, -0.491, Math.PI]}
        />
        <mesh
          geometry={nodes.human002.geometry}
          material={materials.logoSculpture}
          position={[15.009, -0.045, -46.33]}
          rotation={[Math.PI, -0.302, Math.PI]}
        />
        <mesh
          geometry={nodes.human003.geometry}
          material={materials.logoSculpture}
          position={[-21.263, -0.045, -90.278]}
          rotation={[0, -1.34, 0]}
        />
        <mesh
          geometry={nodes.entranceRoofGlass.geometry}
          // material={materials['Roof Glass']}
          position={[0.892, 7.404, -8.343]}
        >
          <meshStandardMaterial
            color="#FFFFFF"
            // metalness={0.5}
            roughness={0}
            transparent
            opacity={0.2}
          />
        </mesh>
        <mesh
          geometry={nodes.island001.geometry}
          material={materials['rock.001']}
          position={[-250.715, 0, -296.708]}
          scale={36.713}
        />
        <mesh
          geometry={nodes.island002.geometry}
          material={materials['rock.001']}
          position={[-283.332, -0.972, -265.452]}
          rotation={[-Math.PI, 1.53, -Math.PI]}
          scale={28.756}
        />
        <mesh
          geometry={nodes.island003.geometry}
          material={materials['rock.001']}
          position={[-217.109, -0.27, -323.345]}
          rotation={[0, 1.5, 0]}
          scale={23.858}
        />
        {/* <mesh
          geometry={nodes.island005.geometry}
          material={materials['rock.001']}
          position={[-140.402, -0.223, -40.052]}
          rotation={[0, -0.274, 0]}
          scale={42.645}
        /> */}
        {/* <mesh
          geometry={nodes.island004.geometry}
          material={materials['rock.001']}
          position={[-82.945, -1.914, -44.586]}
          rotation={[0, 1.252, 0]}
          scale={42.295}
        /> */}
        <mesh
          geometry={nodes.island006.geometry}
          material={materials['rock.001']}
          position={[10.547, -0.223, -225.383]}
          rotation={[Math.PI, -0.988, Math.PI]}
          scale={36.713}
        />
        <mesh
          geometry={nodes.island008.geometry}
          material={materials['rock.001']}
          position={[185.985, -0.223, -265.611]}
          rotation={[0, -0.515, 0]}
          scale={36.713}
        />
        <mesh
          geometry={nodes.island007.geometry}
          material={materials['rock.001']}
          position={[22.29, -1.914, -185.296]}
          rotation={[0, -0.628, 0]}
          scale={42.295}
        />
        <mesh
          geometry={nodes.islandSphere.geometry}
          material={materials.sculpture}
          position={[-290.987, 7.529, -331.563]}
        />
        {/* <mesh
          ref={waterBack}
          // geometry={nodes.outdoorWaterBack.geometry}
          // material={materials.ocean}
          position={[-217.3, 1.248, -313.5]}
          // rotation={[-Math.PI * 0.5, 4, 0]}
          // rotation-z={Math.PI}
          // rotation-x={-Math.PI * 0.5}
        >
          <planeGeometry args={[400, 400]} />
          <MeshReflectorMaterial
            blur={1}
            resolution={2048}
            mixBlur={1}
            mixStrength={100}
            roughness={0.3}
            depthScale={0.2}
            minDepthThreshold={0.9}
            maxDepthThreshold={1.4}
            color="#0f1112"
            metalness={0}
          />
        </mesh> */}
        {/* <mesh
          geometry={nodes.outdoorWaterFront.geometry}
          material={materials.ocean}
          position={[2.279, -0.019, -70.591]}
        /> */}
        <mesh
          rotation={nodes.outdoorWaterFront.rotation}
          rotation-x={-Math.PI * 0.5}
          position={[2.279, -0.01, -70.591]}
        >
          <planeGeometry args={[800, 800]} />
          <MeshReflectorMaterial
            blur={1}
            resolution={2048}
            mixBlur={1}
            mixStrength={100}
            roughness={0.3}
            depthScale={0.2}
            minDepthThreshold={0.9}
            maxDepthThreshold={1.4}
            color="#0f1112"
            metalness={0}
          />
        </mesh>
        <mesh
          geometry={nodes.plantFrontGroup.geometry}
          material={materials['plant-1.001']}
          position={[-12.401, -0.097, -5.22]}
          rotation={[-1.017, -1.093, -0.963]}
        />
        <group position={[-39.903, 0.289, -119.987]} rotation={[0, -1.313, 0]}>
          <mesh
            geometry={nodes.Mesh045.geometry}
            material={materials['Leafs_Plante_01.001']}
          />
          <mesh
            geometry={nodes.Mesh045_1.geometry}
            material={materials['plant-1.001']}
          />
          <mesh
            geometry={nodes.Mesh045_2.geometry}
            material={materials['Leafs_Plante_04.002']}
          />
        </group>
        <mesh
          geometry={nodes.sphere005.geometry}
          material={materials.sculpture}
          position={[-64.611, 2.429, -140.891]}
        />
        <mesh
          geometry={nodes.sphere006.geometry}
          material={materials.sculpture}
          position={[-38.04, 15.327, -113.847]}
        />
      </group>
    </>
  );
}

{
  /* <mesh
  // geometry={nodes.circularRoomPoolWater.geometry}
  // material={materials.ocean}
  position={[-38.268, 0.26, -114.098]}
  rotation={nodes.circularRoomPoolWater.rotation}
  rotation-x={-Math.PI * 0.5}
>
  <circleGeometry args={[15, 25]} />
  <MeshReflectorMaterial
    blur={[300, 100]}
    resolution={2048}
    mixBlur={1}
    mixStrength={50}
    roughness={0.2}
    depthScale={1.2}
    minDepthThreshold={0.4}
    maxDepthThreshold={1.4}
    color="#0f1112"
    metalness={0}
  />
</mesh>; */
}

{
  /* <mesh
  receiveShadow
  rotation={[-Math.PI / 2, 0, 0]}
  position={[0.183, 0.015, -19.383]}
>
  <planeGeometry args={[300, 300]} />
  <MeshReflectorMaterial
    blur={1024}
    // blur={2048}
    resolution={1024}
    mixBlur={10}
    mixStrength={100}
    roughness={1}
    depthScale={1.2}
    minDepthThreshold={0.4}
    maxDepthThreshold={1.4}
    color="#212121"
    metalness={0.25}
    // map={floorTextureMap2}
    // normalMap={floorTextureMapNormal2}
    // normalMapType={THREE.ObjectSpaceNormalMap}
    // roughnessMap={floorTextureMapRoughness2}
    // bumpMap={floorTextureMap}
    aoMap={floorTextureMap}
    aoMapIntensity={2}
  />
</mesh> */
}

useGLTF.preload(MODEL_URL);

export default Model;
