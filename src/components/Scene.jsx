/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.18 portfolio03.glb 
*/

import React, { useEffect, useMemo, useRef, useState } from 'react';
import {
  CameraShake,
  MeshReflectorMaterial,
  PerspectiveCamera,
  Stats,
  useGLTF,
  useScroll,
} from '@react-three/drei';
// import { MeshReflectorMaterial } from './MeshReflectorMaterial';
import { OrbitControls } from '../util/OrbitControlsCustom';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { extend, useFrame, useThree } from '@react-three/fiber';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import {
  MeshBVH,
  MeshBVHHelper,
  StaticGeometryGenerator,
} from 'three-mesh-bvh';
import useKeyboard from '../hooks/useKeyboard';
import { useControls } from 'leva';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { create } from 'zustand';
import { ACTIONS, CharacterControls } from '../util/characterControls';
import { v4 as uuidv4 } from 'uuid';
import { Fluid } from '@alienkitty/alien.js/three';
import gsap from 'gsap';

import { loadCurveFromJSON } from '../util/curveTools/CurveMethods';

import videoSource from '/assets/video/zajno_showreel.mp4';
import floorTexture from '/assets/textures/cineshader_floor.jpeg';
import tileTexture from '/assets/textures/Tiles076_4K-JPG_Color.jpg';
import bakedFloor from '/assets/textures/baked/bakedFloor01.webp';
import floorTextureBaked01 from '/assets/textures/baked/floor001_Bake1_CyclesBake_COMBINED.png';
import cloudTexture01 from '/assets/textures/clouds/cloud1.jpg';
import cloudTexture02 from '/assets/textures/clouds/cloud2.jpg';
import cloudTexture03 from '/assets/textures/clouds/cloud3.jpg';
import Clouds from './Clouds';
import WaterSurfaceSimple from './water/WaterSurfaceSimple';
import { Perf } from 'r3f-perf';
import FluidSim from './water/FluidSim';
// import FluidFX from './water/FluidFx';
import WaterTest from './water/WaterTest';
import titleImage from '/assets/images/title/KENNY CHOI.png';
import bonsaiImage from '/assets/images/bonsai/bonsai tree_.png';
import TitleTest from './TitleTest';
import { useStore } from '../App';
import Bonsai from './Bonsai';
import useScrollBlock from '../hooks/useScrollBlock';
import WaterSurfaces from './water/WaterSurfaces';
import TitleEnd from './TitleEnd';

// extend({ MeshReflectorMaterial });

var textureURL =
  'https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/lroc_color_poles_1k.jpg';
var displacementURL =
  'https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/ldem_3_8bit.jpg';
var worldURL = 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/17271/hipp8_s.jpg';

const MODEL_URL = '/assets/models/portfolio06.glb';
const params = {
  firstPerson: true,
  displayCollider: false,
  displayBVH: false,
  visualizeDepth: 10,
  gravity: -50,
  playerWalkSpeed: 10, // 10
  playerRunSpeed: 50, // 25
  playerJumpHeight: 20,
  physicsSteps: 5,
  cameraOffsetY: 1.5,
  // startPosition: {
  //   // debug
  //   x: -2.59715775502132,
  //   y: -7.57213251605731,
  //   z: 7.25489462321836,
  // },
  startPosition: {
    // outdoors front
    x: 2,
    y: 10,
    z: 30.84643452606501,
  },
  // startPosition: {
  //   // outdoors back
  //   x: -75.87103553276128,
  //   y: 2,
  //   z: -41.36782889639384,
  // },
  // startPosition: {
  //   // indoors entrance
  //   x: 24.96,
  //   y: 20,
  //   z: 75.35,
  // },
  // startPosition: {
  //   // indoors entrance
  //   x: -38,
  //   y: 10,
  //   z: -110,
  // },
};

const LOOK_AT_POSITIONS = {
  START: {
    x: 2.413,
    y: 3.56651711467,
    z: -9.259,
  },
  SCULPTURE: {
    x: -5.41359,
    y: 3.56651711467,
    z: -30.5556,
    scrollProgress: 0.06171620420657648,
  },
  C1: {
    x: 12.0733,
    y: 3.56651711467,
    z: -52.7959,
    // scrollPosition: 3200,
    scrollProgress: 0.1599440195931424,
  },
  C2: {
    x: -0.946431,
    y: 3.56651711467,
    z: -72.4519,
    // scrollPosition: 5100,
    scrollProgress: 0.2549107812265707,
  },
  C3: {
    x: 10.3668,
    y: 3.56651711467,
    z: -92.2975,
    // scrollPosition: 6800,
    scrollProgress: 0.3398810416354276,
  },
  C4: {
    x: -10.1108,
    y: 3.56651711467,
    z: -110.121,
    // scrollPosition: 8600,
    scrollProgress: 0.4298495526565702,
  },
  PLANT: {
    x: -30.9524,
    y: 3.56651711467,
    z: -107.544,
  },
  ROCK: {
    x: -37.8722,
    y: 3.56651711467,
    z: -114.15,
  },
  C5: {
    x: -31.094,
    y: 3.56651711467,
    z: -89.643,
    // scrollPosition: 8600, // needs update
    scrollProgress: 0.4298495526565702, // needs update
  },
  C6: {
    x: -59.5351,
    y: 3.56651711467,
    z: -98.9969,
    // scrollPosition: 8600, // needs update
    scrollProgress: 0.4298495526565702, // needs update
  },
  C7: {
    x: -64.5281,
    y: 3.56651711467,
    z: -118.526,
    // scrollPosition: 8600, // needs update
    scrollProgress: 0.4298495526565702, // needs update
  },
  END: {
    x: -97.2037,
    y: 3.56651711467,
    z: -164.411,
  },
};

const ACTIVE_PROJECT_MAPPING = {
  1: 'C1',
  2: 'C2',
  3: 'C3',
  4: 'C4',
  5: 'C5',
  6: 'C6',
  7: 'C7',
};

// const FOG_PARAMS = {
//   // fogHorizonColor: 0xe4dcff,
//   fogHorizonColor: 0xf4f3f1,
//   fogDensity: 0.0,
// };

// export const useStore = create((set) => ({
//   animationsMap: new Map(),
//   addAnimation: (key, value) =>
//     set((state) => ({ animationsMap: state.animationsMap.set(key, value) })),
//   mixer: new THREE.AnimationMixer(),
//   orbitControls: null,
//   setOrbitControls: (value) => set(() => ({ orbitControls: value })),
//   scrollProgress: 0,
//   setScrollProgress: (value) => set(() => ({ scrollProgress: value })),
//   activeProject: null,
//   setActiveProject: (value) => set(() => ({ activeProject: value })),
// }));

function Model(props) {
  // const [video] = useState(() => {
  //   const video = document.createElement('video');
  //   video.src = videoSource;
  //   video.loop = true;
  //   video.muted = true;
  //   video.autoplay = true;
  //   video.crossOrigin = 'anonymous';
  //   video.play();
  //   return video;
  // });
  // use zustand store to set scroll progress
  const setScrollProgress = useStore((state) => state.setScrollProgress);
  const activeProject = useStore((state) => state.activeProject);
  const setActiveProject = useStore((state) => state.setActiveProject);
  const setActiveCursor = useStore((state) => state.setActiveCursor);

  const { nodes: characterNodes, animations: characterAnimations } = useGLTF(
    '/assets/models/crypto03.glb'
  );

  const { scene, camera, gl, raycaster } = useThree();
  const cameraGroup = useRef(null);
  const character = useRef(null);
  const activeProjectRef = useRef(null);

  const { nodes, materials } = useGLTF(MODEL_URL);

  // const skySphere = useRef(null);

  const scrollProgress = useRef(0);
  const cameraPositionPathData = useRef(null);
  const cameraLookAtPathData = useRef(null);

  const curvePosition = {
    x: 0,
    y: 1.5,
    z: 0,
  };
  // const curvePosition = {
  //   x: 2.1601,
  //   y: 2.0665,
  //   z: 0,
  // };
  // const curvePosition = {
  //   x: 2.1601,
  //   y: 2.0665,
  //   z: 44.755,
  // };

  // const savedScrollY = useRef(null);

  // useEffect(() => {
  //   activeProjectRef.current = activeProject;
  //   if (activeProject) {
  //     savedScrollY.current = window.scrollY;
  //   }
  // }, [activeProject]);

  useEffect(() => {
    const loadCameraPositionData = async () => {
      const JSONPath = '/assets/models/cameraPosition.json';
      const data = await loadCurveFromJSON(JSONPath, 0xff0000);
      // const curvePosition = nodes.cameraPosition.position;
      data.mesh.position.set(curvePosition.x, curvePosition.y, curvePosition.z);
      // scene.add(data.mesh);
      cameraPositionPathData.current = data;
    };
    loadCameraPositionData();
    const loadCameraLookAtData = async () => {
      const JSONPath = '/assets/models/cameraLookAt.json';
      const data = await loadCurveFromJSON(JSONPath, 0xff0000);
      // const curvePosition = nodes.cameraPosition.position;
      data.mesh.position.set(curvePosition.x, curvePosition.y, curvePosition.z);
      // scene.add(data.mesh);
      cameraLookAtPathData.current = data;
    };
    loadCameraLookAtData();
  }, []);

  // const fog = useMemo(() => {
  //   const fog = new THREE.FogExp2(
  //     FOG_PARAMS.fogHorizonColor,
  //     FOG_PARAMS.fogDensity
  //   );
  //   return fog;
  // }, []);

  // useEffect(() => {
  //   const fogInstance = fog;
  //   scene.fog = fogInstance;
  // }, []);

  useEffect(() => {}, []);

  useEffect(() => {
    activeProjectRef.current = activeProject;
  }, [activeProject]);

  const snappedPosition = useRef(window.scrollY);

  const FOOTER_HEIGHT = window.innerHeight;

  useEffect(() => {
    const handleScroll = (e) => {
      if (
        activeProjectRef.current &&
        Math.abs(snappedPosition.current - window.scrollY) > 750
      ) {
        setActiveProject(null);
      }

      // scrollProgress.current =
      //   window.scrollY / (document.body.scrollHeight + window.innerHeight);
      // scrollProgress.current =
      //   window.scrollY / (document.body.scrollHeight - window.innerHeight);

      // update scroll progress based on scroll position excluding footer with height of 100vh (window.innerHeight)

      const totalScrollableHeight =
        document.body.scrollHeight - window.innerHeight - FOOTER_HEIGHT;
      scrollProgress.current = Math.min(
        window.scrollY / totalScrollableHeight,
        1
      );

      const scrollProgressPixels = window.scrollY;
      console.log(scrollProgress.current, scrollProgressPixels);
      // setActiveProject(null);
      setScrollProgress(scrollProgress.current);

      // if (scrollProgress.current < 0.0375) {
      //   setActiveProject(null);
      //   gsap.to(myFog, {
      //     value: 0,
      //     duration: 1,
      //     onUpdate: () => {
      //       scene.fog.density = myFog.value;
      //     },
      //   });
      // } else {
      //   gsap.to(myFog, {
      //     value: 0.02,
      //     duration: 2,
      //     onUpdate: () => {
      //       scene.fog.density = myFog.value;
      //     },
      //   });
      // }
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [setScrollProgress]);

  const scrollTimer = useRef(null);

  const myFog = {
    value: 0.0,
  };

  useEffect(() => {
    // // write debounce function to handle scroll snapping
    // const debounce = (func, wait, immediate) => {
    //   let timeout;
    //   return function () {
    //     const context = this,
    //       args = arguments;
    //     const later = function () {
    //       timeout = null;
    //       if (!immediate) func.apply(context, args);
    //     };
    //     const callNow = immediate && !timeout;
    //     clearTimeout(timeout);
    //     timeout = setTimeout(later, wait);
    //     if (callNow) func.apply(context, args);
    //   };
    // };

    const handleScrollSnap = () => {
      // if (activeProjectRef.current !== null) return;
      // if (scrollTimer.current) {
      clearTimeout(scrollTimer.current);
      // }

      let scrollPosition = window.scrollY;
      if (scrollProgress.current < 0.05) {
        // gsap.to(myFog, {
        //   value: 0,
        //   duration: 1,
        //   onUpdate: () => {
        //     scene.fog.density = myFog.value;
        //   },
        // });
      } else if (
        scrollProgress.current >= 0.05 &&
        scrollProgress.current < 0.09
      ) {
        scrollPosition = getScrollPixelFromProgress(
          LOOK_AT_POSITIONS.SCULPTURE.scrollProgress
        );
        // gsap.to(myFog, {
        //   value: 0.02,
        //   duration: 2,
        //   onUpdate: () => {
        //     scene.fog.density = myFog.value;
        //   },
        // });
      } else if (
        scrollProgress.current >= 0.09 &&
        scrollProgress.current < 0.19
      ) {
        // scrollPosition = 3200;
        scrollPosition = getScrollPixelFromProgress(
          LOOK_AT_POSITIONS.C1.scrollProgress
        );
      } else if (
        scrollProgress.current >= 0.19 &&
        scrollProgress.current < 0.29
      ) {
        scrollPosition = getScrollPixelFromProgress(
          LOOK_AT_POSITIONS.C2.scrollProgress
        );
      } else if (
        scrollProgress.current >= 0.29 &&
        scrollProgress.current < 0.38
      ) {
        scrollPosition = getScrollPixelFromProgress(
          LOOK_AT_POSITIONS.C3.scrollProgress
        );
      } else if (
        scrollProgress.current >= 0.38 &&
        scrollProgress.current < 0.47
      ) {
        scrollPosition = getScrollPixelFromProgress(
          LOOK_AT_POSITIONS.C4.scrollProgress
        );
      } else if (
        scrollProgress.current >= 0.51 &&
        scrollProgress.current < 0.6
      ) {
        scrollPosition = getScrollPixelFromProgress(
          LOOK_AT_POSITIONS.C5.scrollProgress
        );
      }
      scrollTimer.current = setTimeout(() => {
        // if (activeProjectRef.current) return;
        window.scrollTo({ top: scrollPosition, behavior: 'smooth' });
        // setActiveProject(activeProjectRef.current);
        snappedPosition.current = scrollPosition;
      }, 25);
    };

    const debouncedScrollSnap = handleScrollSnap;
    // const debouncedScrollSnap = debounce(handleScrollSnap, 35);

    window.addEventListener('scroll', debouncedScrollSnap);

    return () => {
      window.removeEventListener('scroll', debouncedScrollSnap);
    };
  }, []);

  const mouse = useRef({
    world: new THREE.Vector2(),
    uv: new THREE.Vector2(),
    isInit: false,
  });
  const rotationTarget = useRef({ x: 0, y: 0, z: 0 });

  useEffect(() => {
    // PARALLAX EFFECT + MOUSE POSITION TRACKING
    const handleMouseMove = (e) => {
      // PARALLAX EFFECT
      const x = e.clientX / window.innerWidth - 0.5;
      const y = e.clientY / window.innerHeight - 0.5;

      rotationTarget.current.y = -x * 1;
      rotationTarget.current.x = -y * 1;

      // MOUSE POSITION TRACKING
      const event = {
        x: (e.clientX / window.innerWidth) * 2 - 1,
        y: -(e.clientY / window.innerHeight) * 2 + 1,
      };

      if (!mouse.current.isInit) {
        mouse.current.isInit = true;
        mouse.current.world.copy(event);
        mouse.current.uv.copy(event);
      }
      mouse.current.world.copy(event);
    };

    window.addEventListener('mousemove', handleMouseMove);

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);

  const canvas01 = useRef(null);
  const canvas02 = useRef(null);
  const canvas03 = useRef(null);
  const canvas04 = useRef(null);
  const canvas05 = useRef(null);
  const canvas06 = useRef(null);
  const canvas07 = useRef(null);

  const handleCanvasClick = (e, canvasId) => {
    if (e.distance > 10) return;
    e.stopPropagation();
    if (!activeProject) {
      setActiveProject(canvasId);
      setActiveCursor(true);
    } else {
      setActiveProject(null);
      setActiveCursor(false);
    }
  };

  const handleCanvasMouseEnter = (e) => {
    e.stopPropagation();
    if (e.distance > 10) {
      setActiveCursor(false);
      return;
    }
    setActiveCursor(true);
    // set cursor to pointer
    document.body.style.cursor = 'pointer';
  };

  const handleCanvasMouseLeave = (e) => {
    e.stopPropagation();
    setActiveCursor(false);
    // reset cursor
    document.body.style.cursor = 'auto';
  };

  const world = useRef(null);

  // const videoTexture = useMemo(() => {
  //   const texture = new THREE.VideoTexture(video);
  //   // texture.minFilter = THREE.LinearFilter;
  //   // texture.magFilter = THREE.LinearFilter;
  //   // texture.format = THREE.RGBFormat;
  //   texture.flipY = false;
  //   return texture;
  // }, [video]);

  // const uniforms = useMemo(
  //   () => ({
  //     uTime: { value: 0 },
  //     uVideoTexture: { value: videoTexture },
  //     uFluid: { value: null },
  //     // uRGBShift: { value: 1 },
  //   }),
  //   []
  // );

  // const shaderMaterial = useMemo(() => {
  //   return new THREE.ShaderMaterial({
  //     uniforms: uniforms,
  //     vertexShader: `
  //       varying vec2 vUv;

  //       void main() {
  //         vUv = uv;
  //         gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  //       }
  //     `,
  //     fragmentShader: `
  //       uniform float uTime;
  //       uniform sampler2D uVideoTexture;
  //       uniform sampler2D uFluid;
  //       // uniform int uRGBShift;

  //       varying vec2 vUv;

  //       void main() {
  //         vec3 fluid = texture2D(uFluid, vUv).rgb;
  //         vec2 uv = vUv;
  //         vec2 uv2 = vUv - (fluid.xy * .001);
  //         vec4 color = texture2D(uVideoTexture, uv2);
  //         // vec3 rgb = fluid * 0.0001;

  //         // color.r = texture2D(uVideoTexture, vec2(uv.x+rgb.x, uv.y+rgb.y)).r;
  //         // color.g = texture2D(uVideoTexture, vec2(uv.x-rgb.x, uv.y+rgb.y)).g;
  //         // color.b = texture2D(uVideoTexture, vec2(uv.x-rgb.x, uv.y-rgb.y)).b;
  //         gl_FragColor = color;
  //         // gl_FragColor = vec4(vUv, 1.0, 1.0);
  //       }
  //     `,
  //   });
  // }, []);

  const getLookAtPosition = (scrollProgress) => {
    let key = 'START';
    if (scrollProgress < 0.045) {
      key = 'START';
    } else if (scrollProgress < 0.08) {
      key = 'SCULPTURE';
    } else if (scrollProgress < 0.17) {
      key = 'C1';
    } else if (scrollProgress < 0.275) {
      key = 'C2';
    } else if (scrollProgress < 0.35) {
      key = 'C3';
    } else if (scrollProgress < 0.44) {
      key = 'C4';
    } else if (scrollProgress < 0.49) {
      key = 'PLANT';
    } else if (scrollProgress < 0.6) {
      key = 'C5';
    } else if (scrollProgress < 0.686) {
      key = 'C6';
    } else if (scrollProgress < 0.775) {
      key = 'C7';
    } else if (scrollProgress < 0.89) {
      key = 'ROCK';
      // key = 'END';
    } else {
      key = 'END';
    }
    return key;
  };

  const bonsaiTexture = useMemo(() => {
    const texture = new THREE.TextureLoader().load(bonsaiImage);
    return texture;
  }, []);

  const uniforms = useMemo(() => {
    return {
      uTexture: { value: bonsaiTexture },
      uFluid: { value: null },
    };
  }, []);

  const bonsaiRef = useRef(null);
  const [showEnd, setShowEnd] = useState(false);
  const showEndRef = useRef(false);

  const getScrollPixelFromProgress = (progress) => {
    const totalCurveLength = cameraPositionPathData.current.curve.getLength();
    const totalViewportHeight =
      document.body.scrollHeight - window.innerHeight - FOOTER_HEIGHT;
    const currentCurvePosition = progress * totalCurveLength;
    const currentCurveProgress = currentCurvePosition / totalCurveLength;
    const currentScrollPosition = currentCurveProgress * totalViewportHeight;

    return currentScrollPosition;
  };

  useFrame((state, delta) => {
    const scrollProgressPixels = window.scrollY;
    // console.log(scrollProgress.current, scrollProgressPixels);
    // // console.log('scrollProgress.current: ', scrollProgress.current);
    // console.log('activeProject: ', activeProject);
    // console.log('savedScrollY.current: ', savedScrollY.current);
    // console.log('-------------------');
    // update uTime uniform
    // uniforms.uTime.value = state.clock.elapsedTime;

    // if (fluid.current) {
    //   if (fluid.current.uniform) {
    //     canvas01.current.material.uniforms.uFluid.value =
    //       fluid.current.uniform.value;
    //   }

    //   fluid.current.iterate = iterate;
    //   fluid.current.densityDissipation = density;
    //   fluid.current.velocityDissipation = velocity;
    //   fluid.current.pressureDissipation = pressure;
    //   fluid.current.curlStrength = curl;
    //   fluid.current.radius = radius;
    //   fluid.current.update();
    // }

    if (cameraPositionPathData.current && cameraLookAtPathData.current) {
      // if (activeProject !== null) {
      //   const lookAtKey = ACTIVE_PROJECT_MAPPING[activeProject];
      //   const lookAtPosition = LOOK_AT_POSITIONS[lookAtKey];

      //   scrollProgress.current = lookAtPosition.scrollProgress;
      //   setScrollProgress(lookAtPosition.scrollProgress);
      //   window.scrollTo({
      //     top: getScrollPixelFromProgress(lookAtPosition.scrollProgress),
      //     behavior: 'instant',
      //   });
      // }
      const curve = cameraPositionPathData.current.curve;
      // console.log('curve.length: ', curve.getLength());
      const point = curve.getPoint(scrollProgress.current);
      // console.log('pixels: ', getScrollPixelFromProgress(0.15784541015143294));
      // points are relative to curve global position so we need to add the camera position
      point.add(curvePosition);

      const xPos = point.x - rotationTarget.current.y + (activeProject ? 1 : 0);
      const yPos = point.y + rotationTarget.current.x + (activeProject ? 1 : 0);
      const zPos = point.z + (activeProject ? 2 : 0);

      gsap.to(camera.position, {
        x: xPos,
        y: yPos,
        z: zPos,
        duration: 0.75,
      });

      const lookAtKey = getLookAtPosition(scrollProgress.current);
      const lookAtPosition = LOOK_AT_POSITIONS[lookAtKey];

      const target = camera.clone();
      target.lookAt(
        new THREE.Vector3(
          lookAtPosition.x + (activeProject ? 2 : 0),
          lookAtPosition.y,
          lookAtPosition.z
        )
      );

      const rotationSpeed = scrollProgress.current >= 0.79 ? 0.1 : 0.03;
      camera.quaternion.slerp(target.quaternion, rotationSpeed);
      // camera.quaternion.slerp(target.quaternion, 0.025);
    }

    if (scrollProgress.current >= 0.05) {
      setShowEnd(true);
    } else {
      setShowEnd(false);
    }

    raycaster.setFromCamera(mouse.current.world, camera);
    const intersects = raycaster.intersectObjects([
      canvas01.current,
      canvas02.current,
      canvas03.current,
      canvas04.current,
      canvas05.current,
      canvas06.current,
      canvas07.current,
    ]);

    if (intersects.length > 0 && intersects[0].distance < 10) {
      setActiveCursor(true);
    } else if (intersects.length) {
      setActiveCursor(false);
    }
    //  else {
    //   setActiveCursor(false);
    // }
  });

  const waterBack = useRef(null);

  useEffect(() => {
    if (waterBack.current) {
      // rotate the water back plane
      // waterBack.current.rotation.y = 0;
      waterBack.current.rotation.x = -Math.PI * 0.5;
    }
  }, []);

  const waterInteriorGeometry = useMemo(() => {
    return new THREE.CircleGeometry(15, 25);
  }, []);

  // const waterExterior = useRef(null);

  // useEffect(() => {
  //   console.log('waterExterior: ', waterExterior.current);
  // }, []);

  // const titleTexture = useMemo(() => {
  //   const texture = new THREE.TextureLoader().load(titleImage);
  //   texture.flipY = false;
  //   return texture;
  // }, []);

  return (
    <>
      {/* <Stats /> */}
      {/* <OrbitControls
        ref={controls}
        mouseButtons={{
          LEFT: THREE.MOUSE.ROTATE,
          RIGHT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.ROTATE,
          }}
          /> */}
      <TitleTest />
      <Clouds />
      {showEnd && (
        <>
          {/* <TitleEnd />
          <Bonsai /> */}
        </>
      )}

      <WaterSurfaces />

      <group ref={cameraGroup}>
        {/* <CameraShake
          intensity={0.1}
          decay={true}
          decayRate={0.5}
          active={true}
          speed={0.1}
          maxRotation={0.1}
          maxTranslation={0.1}
          maxZoom={0.1}
          minRotation={0.01}
          minTranslation={0.1}
          minZoom={0.0}
        /> */}
        <PerspectiveCamera
          makeDefault
          // ref={camera}
          fov={75}
          aspect={window.innerWidth / window.innerHeight}
          near={0.1}
          far={1000}
          // far={300}
          zoom={1}
          // position={[0, 1.5, 0]}
        />
      </group>
      <group ref={world} {...props} dispose={null}>
        <group
          position={[-81.585, 1.546, -155.711]}
          rotation={[-Math.PI / 2, 0, 0]}
        >
          <group rotation={[Math.PI / 2, 0, 0]}>
            <group position={[-0.301, -0.125, -0.095]}>
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0.geometry}
                material={materials.pine_2_1Mat}
              />
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0_1.geometry}
                material={materials.trunk_2_1_0Mat}
              />
            </group>
            <group
              position={[-5.016, -0.125, 5.02]}
              rotation={[-Math.PI, 0.425, -Math.PI]}
            >
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0003.geometry}
                material={materials.pine_2_1Mat}
              />
              <mesh
                geometry={nodes.pine_2_1_pine_2_1Mat_0003_1.geometry}
                material={materials.trunk_2_1_0Mat}
              />
            </group>
          </group>
        </group>
        <mesh
          geometry={nodes.rockGroup_Baked.geometry}
          material={materials.rockGroup_Baked}
          position={[-38.04, 0.134, -113.847]}
          rotation={[1.81, 0.887, 2.375]}
        />
        <mesh
          geometry={nodes.entranceWalls_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[0, -0.028, -13.737]}
        />
        <mesh
          geometry={nodes.entranceCurvedWall_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[-6.25, 4.315, -18.294]}
        />
        <mesh
          geometry={nodes.entranceRoof_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[-0.001, 3.242, -13.737]}
        />
        <mesh
          geometry={nodes.entranceRoofWindows_Baked.geometry}
          material={materials.entranceWalls_Baked}
          position={[2.223, 7.458, -8.255]}
        />
        <mesh
          geometry={nodes.entranceCurvedRoomPedestal_Baked.geometry}
          material={materials.entranceFloorAndPedestal_Baked}
          position={[-5.211, 0.496, -30.827]}
        />
        <mesh
          geometry={nodes.floor001_Baked.geometry}
          material={materials.entranceFloorAndPedestal_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.entranceCurvedRoom_Baked.geometry}
          material={materials.entranceRoundWalls_Baked}
          position={[-4.383, 5.782, -31.047]}
        />
        <mesh
          geometry={nodes.entranceCurvedRoomTop_Baked.geometry}
          material={materials.entranceRoundWalls_Baked}
          position={[-1.632, 9.146, -30.827]}
        />
        <mesh
          geometry={nodes.mainRoomTop001_Baked.geometry}
          material={materials.mainHallFloorAndTop_Baked}
          position={[6.161, 16.353, -65.066]}
        />
        <mesh
          geometry={nodes.mainRoomWalls_Baked.geometry}
          material={materials.mainHallWalls_Baked}
          position={[6.191, -0.001, -41.53]}
        />
        <mesh
          geometry={nodes.mainRoomTop002_Baked.geometry}
          material={materials.mainHallWalls_Baked}
          position={[0.682, 16.351, -97.22]}
        />
        <mesh
          geometry={nodes.floor003_Baked.geometry}
          material={materials.floor003_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.floor003001_Baked.geometry}
          material={materials.mainCircularRoomFloors_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.floor003002_Baked.geometry}
          material={materials.mainCircularRoomFloors_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.circularRoom_Baked.geometry}
          material={materials.circularRoom_Baked}
          position={[-38.268, 0.726, -114.098]}
          rotation={[0, -0.113, 0]}
        />
        <mesh
          geometry={nodes.circularRoomTop_Baked.geometry}
          material={materials.circularRoomTop_Baked}
          position={[-38.268, 18.336, -114.098]}
        />
        <mesh
          geometry={nodes.floor002_Baked.geometry}
          material={materials.floor002_Baked}
          position={[0.183, 0, -19.383]}
        />
        <mesh
          geometry={nodes.logoSculpture_Baked.geometry}
          material={materials.logoSculpture_Baked}
          position={[-5.387, 3.083, -30.796]}
          rotation={[-2.359, 0.205, 0.281]}
        />
        <mesh
          geometry={nodes.circularRoomPool_Baked.geometry}
          material={materials.mainCircularRoomPool_Baked}
          position={[-38.268, 0.16, -114.098]}
        />
        <mesh
          geometry={nodes.sculptureSorento_Baked.geometry}
          material={materials.mainCircularRoomPool_Baked}
          position={[-51.429, 0.004, -138.733]}
        />
        <mesh
          geometry={nodes.outdoorStairs_Baked.geometry}
          material={materials.outdoorStairs_Baked}
          position={[-61.17, 0, -133.453]}
          rotation={[0, 0.073, 0]}
        />
        <mesh
          geometry={nodes.archOutdoor_Baked.geometry}
          material={materials.arches_Baked}
          position={[-82.72, 9.846, -151.925]}
          rotation={[0, -0.7, 0]}
        />
        <mesh
          geometry={nodes.arch001_Baked.geometry}
          material={materials.arches_Baked}
          position={[-61.189, 0.957, -133.464]}
          rotation={[Math.PI / 2, 0, -0.871]}
        />
        <mesh
          geometry={nodes.canvasBack001.geometry}
          material={materials.canvasBack}
          position={[12.034, 3, -53.031]}
          rotation={[0, -0.422, 0]}
        />
        {/* <mesh
          // geometry={nodes.circularRoomPoolWater.geometry}
          // material={materials.ocean}
          position={[-38.268, 0.26, -114.098]}
          rotation={nodes.circularRoomPoolWater.rotation}
          rotation-x={-Math.PI * 0.5}
        >
          <circleGeometry args={[15, 25]} />
          <MeshReflectorMaterial
            // blur={[300, 100]}
            // resolution={2048}
            // mixBlur={1}
            // mixStrength={50}
            // roughness={0.2}
            // depthScale={1.2}
            // minDepthThreshold={0.4}
            // maxDepthThreshold={1.4}
            // color="#0f1112"
            // metalness={0}
            blur={[300, 100]}
            resolution={2048}
            mixBlur={1}
            mixStrength={50}
            roughness={0.2}
            depthScale={1.2}
            minDepthThreshold={0.4}
            maxDepthThreshold={1.4}
            color="#0f1112"
            metalness={0}
          />
        </mesh> */}
        <mesh
          geometry={nodes.sphere003.geometry}
          material={materials.sculpture}
          position={[3.486, 1.018, -107.404]}
        />
        <mesh
          geometry={nodes.columns.geometry}
          material={materials.benches}
          position={[16.643, 0, -35.363]}
        />
        <mesh
          ref={canvas01}
          geometry={nodes.canvas001.geometry}
          material={materials.Canvas01}
          position={[12.013, 3.027, -53.04]}
          rotation={[0, -0.422, 0]}
          onClick={(e) => handleCanvasClick(e, 1)}
          onPointerEnter={handleCanvasMouseEnter}
          onPointerMove={handleCanvasMouseEnter}
          onPointerLeave={handleCanvasMouseLeave}
        />
        <mesh
          geometry={nodes.canvasBack002.geometry}
          material={materials.canvasBack}
          position={[-0.787, 3, -72.638]}
          rotation={[0, 0.42, 0]}
        />
        <mesh
          ref={canvas02}
          geometry={nodes.canvas002.geometry}
          material={materials.Canvas02}
          position={[-0.787, 3.028, -72.638]}
          rotation={[0, 0.42, 0]}
          onClick={(e) => handleCanvasClick(e, 2)}
          onPointerEnter={handleCanvasMouseEnter}
          onPointerMove={handleCanvasMouseEnter}
          onPointerLeave={handleCanvasMouseLeave}
        />
        <mesh
          geometry={nodes.canvasBack003.geometry}
          material={materials.canvasBack}
          position={[10.63, 3, -92.398]}
          rotation={[0, -0.454, 0]}
        />
        <mesh
          ref={canvas03}
          geometry={nodes.canvas003.geometry}
          material={materials.Canvas03}
          position={[10.63, 3.03, -92.398]}
          rotation={[0, -0.454, 0]}
          onClick={(e) => handleCanvasClick(e, 3)}
          onPointerEnter={handleCanvasMouseEnter}
          onPointerMove={handleCanvasMouseEnter}
          onPointerLeave={handleCanvasMouseLeave}
        />
        <mesh
          geometry={nodes.canvasBack004.geometry}
          material={materials.canvasBack}
          position={[-10.216, 3, -110.056]}
          rotation={[0, 0.556, 0]}
        />
        <mesh
          ref={canvas04}
          geometry={nodes.canvas004.geometry}
          material={materials.Canvas04}
          position={[-10.216, 3.038, -110.056]}
          rotation={[0, 0.556, 0]}
          onClick={(e) => handleCanvasClick(e, 4)}
          onPointerEnter={handleCanvasMouseEnter}
          onPointerMove={handleCanvasMouseEnter}
          onPointerLeave={handleCanvasMouseLeave}
        />
        <mesh
          geometry={nodes.canvasBack005.geometry}
          material={materials.canvasBack}
          position={[-30.974, 3, -89.757]}
          rotation={[-Math.PI, 0.793, -Math.PI]}
        />
        <mesh
          ref={canvas05}
          geometry={nodes.canvas005.geometry}
          material={materials.Canvas05}
          position={[-30.974, 3.021, -89.757]}
          rotation={[-Math.PI, 0.793, -Math.PI]}
          onClick={(e) => handleCanvasClick(e, 5)}
          onPointerEnter={handleCanvasMouseEnter}
          onPointerMove={handleCanvasMouseEnter}
          onPointerLeave={handleCanvasMouseLeave}
        />
        <mesh
          geometry={nodes.canvasBack006.geometry}
          material={materials.canvasBack}
          position={[-59.154, 3, -98.602]}
          rotation={[0, 1.476, 0]}
        />
        <mesh
          ref={canvas06}
          geometry={nodes.canvas006.geometry}
          material={materials.Canvas06}
          position={[-59.154, 3.028, -98.602]}
          rotation={[0, 1.476, 0]}
          onClick={(e) => handleCanvasClick(e, 6)}
          onPointerEnter={handleCanvasMouseEnter}
          onPointerMove={handleCanvasMouseEnter}
          onPointerLeave={handleCanvasMouseLeave}
        />
        <mesh
          geometry={nodes.canvasBack007.geometry}
          material={materials.canvasBack}
          position={[-64.587, 3, -118.668]}
          rotation={[0, 0.714, 0]}
        />
        <mesh
          ref={canvas07}
          geometry={nodes.canvas007.geometry}
          material={materials.Canvas07}
          position={[-64.587, 3.039, -118.668]}
          rotation={[0, 0.714, 0]}
          onClick={(e) => handleCanvasClick(e, 7)}
          onPointerEnter={handleCanvasMouseEnter}
          onPointerMove={handleCanvasMouseEnter}
          onPointerLeave={handleCanvasMouseLeave}
        />
        <mesh
          geometry={nodes.sphere002.geometry}
          material={materials.sculpture}
          position={[-3.167, 1.018, -55.319]}
        />
        <mesh
          geometry={nodes.sphere004.geometry}
          material={materials.sculpture}
          position={[-56.379, 1.018, -92.623]}
        />
        <mesh
          geometry={nodes.recessedLighting.geometry}
          material={materials.ringLight}
          position={[-38.268, 0.726, -114.098]}
          rotation={[0, -0.113, 0]}
        />
        <mesh
          geometry={nodes.benches.geometry}
          material={materials.benches}
          position={[-2.705, 0.235, -5.62]}
          rotation={[-Math.PI, 0, 0]}
        />
        <mesh
          geometry={nodes.sphere001.geometry}
          material={materials.sculpture}
          position={[16.34, 1.018, -34.641]}
        />
        {/* <mesh
          geometry={nodes.outdoorWaterBarrier.geometry}
          material={materials.benches}
          position={[-38.623, -0.785, -159.184]}
          rotation={[0, -0.731, 0]}
        /> */}
        <mesh
          geometry={nodes.human001.geometry}
          material={materials.logoSculpture}
          position={[6.714, -0.045, -14.873]}
          rotation={[Math.PI, -0.491, Math.PI]}
        />
        <mesh
          geometry={nodes.human002.geometry}
          material={materials.logoSculpture}
          position={[15.009, -0.045, -46.33]}
          rotation={[Math.PI, -0.302, Math.PI]}
        />
        <mesh
          geometry={nodes.human003.geometry}
          material={materials.logoSculpture}
          position={[-21.263, -0.045, -90.278]}
          rotation={[0, -1.34, 0]}
        />
        <mesh
          geometry={nodes.entranceRoofGlass.geometry}
          // material={materials['Roof Glass']}
          position={[0.892, 7.404, -8.343]}
        >
          <meshStandardMaterial
            color="#FFFFFF"
            // metalness={0.5}
            roughness={0}
            transparent
            opacity={0.2}
          />
        </mesh>
        {/* <mesh
          geometry={nodes.island001.geometry}
          material={materials['rock.001']}
          position={[-250.715, 0, -296.708]}
          scale={36.713}
        />
        <mesh
          geometry={nodes.island002.geometry}
          material={materials['rock.001']}
          position={[-283.332, -0.972, -265.452]}
          rotation={[-Math.PI, 1.53, -Math.PI]}
          scale={28.756}
        />
        <mesh
          geometry={nodes.island003.geometry}
          material={materials['rock.001']}
          position={[-217.109, -0.27, -323.345]}
          rotation={[0, 1.5, 0]}
          scale={23.858}
        /> */}
        {/* <mesh
          geometry={nodes.island005.geometry}
          material={materials['rock.001']}
          position={[-140.402, -0.223, -40.052]}
          rotation={[0, -0.274, 0]}
          scale={42.645}
        /> */}
        {/* <mesh
          geometry={nodes.island004.geometry}
          material={materials['rock.001']}
          position={[-82.945, -1.914, -44.586]}
          rotation={[0, 1.252, 0]}
          scale={42.295}
        /> */}
        <mesh
          geometry={nodes.island006.geometry}
          material={materials['rock.001']}
          position={[10.547, -0.223, -225.383]}
          rotation={[Math.PI, -0.988, Math.PI]}
          scale={36.713}
        />
        <mesh
          geometry={nodes.island008.geometry}
          material={materials['rock.001']}
          position={[185.985, -0.223, -265.611]}
          rotation={[0, -0.515, 0]}
          scale={36.713}
        />
        <mesh
          geometry={nodes.island007.geometry}
          material={materials['rock.001']}
          position={[22.29, -1.914, -185.296]}
          rotation={[0, -0.628, 0]}
          scale={42.295}
        />
        {/* {showEnd && (
          <mesh
            geometry={nodes.islandSphere.geometry}
            material={materials.sculpture}
            position={[-472.3, 70.529, -487.2]}
            // position={[-290.987, 7.529, -331.563]}
            scale={[12, 12, 12]}
          />
        )} */}
        {/* <mesh
          ref={waterBack}
          // geometry={nodes.outdoorWaterBack.geometry}
          // material={materials.ocean}
          position={[-217.3, 1.248, -313.5]}
          // rotation={[-Math.PI * 0.5, 4, 0]}
          // rotation-z={Math.PI}
          // rotation-x={-Math.PI * 0.5}
        >
          <planeGeometry args={[400, 400]} />
          <MeshReflectorMaterial
            blur={1}
            resolution={2048}
            mixBlur={1}
            mixStrength={100}
            roughness={0.3}
            depthScale={0.2}
            minDepthThreshold={0.9}
            maxDepthThreshold={1.4}
            color="#0f1112"
            metalness={0}
          />
        </mesh> */}
        {/* <mesh
          geometry={nodes.outdoorWaterFront.geometry}
          material={materials.ocean}
          position={[2.279, -0.019, -70.591]}
        /> */}
        {/* <mesh
          rotation={nodes.outdoorWaterFront.rotation}
          rotation-x={-Math.PI * 0.5}
          position={[2.279, -0.01, -70.591]}
        >
          <planeGeometry args={[800, 800]} />
          <MeshReflectorMaterial
            blur={1}
            resolution={2048}
            mixBlur={1}
            mixStrength={100}
            roughness={0.3}
            depthScale={0.2}
            minDepthThreshold={0.9}
            maxDepthThreshold={1.4}
            color="#0f1112"
            metalness={0}
          />
        </mesh> */}
        <mesh
          geometry={nodes.plantFrontGroup.geometry}
          material={materials['plant-1.001']}
          position={[-12.401, -0.097, -5.22]}
          rotation={[-1.017, -1.093, -0.963]}
        />
        <group position={[-39.903, 0.289, -119.987]} rotation={[0, -1.313, 0]}>
          <mesh
            geometry={nodes.Mesh045.geometry}
            material={materials['Leafs_Plante_01.001']}
          />
          <mesh
            geometry={nodes.Mesh045_1.geometry}
            material={materials['plant-1.001']}
          />
          <mesh
            geometry={nodes.Mesh045_2.geometry}
            material={materials['Leafs_Plante_04.002']}
          />
        </group>
        <mesh
          geometry={nodes.sphere005.geometry}
          material={materials.sculpture}
          position={[-64.611, 2.429, -140.891]}
        />
        <mesh
          geometry={nodes.sphere006.geometry}
          material={materials.sculpture}
          position={[-38.04, 15.327, -113.847]}
        />
      </group>
    </>
  );
}

useGLTF.preload(MODEL_URL);

export default Model;
